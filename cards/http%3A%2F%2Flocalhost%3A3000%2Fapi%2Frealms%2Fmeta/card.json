{
  "data": {
    "attributes": {
      "csCreated": "2020-11-17T21:16:22.252Z",
      "csDescription": "This card controls the configuration of the meta realm which is the realm that holds all of your realm cards.",
      "csFields": {
      },
      "csId": "http://localhost:3000/api/realms/meta",
      "csTitle": "Meta Realm",
      "csUpdated": "2020-11-17T21:16:22.252Z",
      "remoteCacheDir": "meta-realm",
      "remoteUrl": "https://thelinuxlich:Eldritch84@github.com/dotbc/cs2_meta_realm.git"
    },
    "id": "http://localhost:3000/api/realms/meta/cards/http%3A%2F%2Flocalhost%3A3000%2Fapi%2Frealms%2Fmeta",
    "relationships": {
      "csAdoptsFrom": {
        "data": {
          "id": "https://base.cardstack.com/public/cards/git-realm",
          "type": "cards"
        }
      }
    },
    "type": "cards"
  },
  "included": [
    {
      "attributes": {
        "csCreated": "2020-11-17T21:16:22.266Z",
        "csFeatures": {
          "indexer": "indexer.js",
          "writer": "writer.js"
        },
        "csFields": {
          "basePath": {
            "relationships": {
              "csAdoptsFrom": {
                "data": {
                  "id": "https://base.cardstack.com/public/cards/string-field",
                  "type": "cards"
                }
              }
            }
          },
          "branch": {
            "relationships": {
              "csAdoptsFrom": {
                "data": {
                  "id": "https://base.cardstack.com/public/cards/string-field",
                  "type": "cards"
                }
              }
            }
          },
          "remoteCacheDir": {
            "relationships": {
              "csAdoptsFrom": {
                "data": {
                  "id": "https://base.cardstack.com/public/cards/string-field",
                  "type": "cards"
                }
              }
            }
          },
          "remoteUrl": {
            "relationships": {
              "csAdoptsFrom": {
                "data": {
                  "id": "https://base.cardstack.com/public/cards/string-field",
                  "type": "cards"
                }
              }
            }
          },
          "repo": {
            "relationships": {
              "csAdoptsFrom": {
                "data": {
                  "id": "https://base.cardstack.com/public/cards/string-field",
                  "type": "cards"
                }
              }
            }
          }
        },
        "csFiles": {
          "card.json": "{\n  \"data\": {\n    \"type\": \"cards\",\n    \"attributes\": {\n      \"csId\": \"git-realm\",\n      \"csFeatures\": {\n        \"writer\": \"writer.js\",\n        \"indexer\": \"indexer.js\"\n      },\n      \"csFields\": {\n        \"repo\": {\n          \"relationships\": {\n            \"csAdoptsFrom\": {\n              \"data\": {\n                \"type\": \"cards\",\n                \"id\": \"https://base.cardstack.com/public/cards/string-field\"\n              }\n            }\n          }\n        },\n        \"branch\": {\n          \"relationships\": {\n            \"csAdoptsFrom\": {\n              \"data\": {\n                \"type\": \"cards\",\n                \"id\": \"https://base.cardstack.com/public/cards/string-field\"\n              }\n            }\n          }\n        },\n        \"basePath\": {\n          \"relationships\": {\n            \"csAdoptsFrom\": {\n              \"data\": {\n                \"type\": \"cards\",\n                \"id\": \"https://base.cardstack.com/public/cards/string-field\"\n              }\n            }\n          }\n        },\n        \"remoteUrl\": {\n          \"relationships\": {\n            \"csAdoptsFrom\": {\n              \"data\": {\n                \"type\": \"cards\",\n                \"id\": \"https://base.cardstack.com/public/cards/string-field\"\n              }\n            }\n          }\n        },\n        \"remoteCacheDir\": {\n          \"relationships\": {\n            \"csAdoptsFrom\": {\n              \"data\": {\n                \"type\": \"cards\",\n                \"id\": \"https://base.cardstack.com/public/cards/string-field\"\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n",
          "indexer.d.ts": "import { Repository, RemoteConfig } from './lib/git';\nimport { Indexer, IndexingOperations } from '@cardstack/hub';\nimport { AddressableCard } from '@cardstack/hub';\ninterface GitMeta {\n    commit?: string;\n}\ndeclare type PathSpec = string | string[];\nexport default class GitIndexer implements Indexer<GitMeta> {\n    private realmCard;\n    repoPath?: string;\n    basePath: PathSpec[];\n    branchPrefix: string;\n    remote?: RemoteConfig;\n    repo?: Repository;\n    constructor(realmCard: AddressableCard);\n    ready(): Promise<void>;\n    update(meta: GitMeta, ops: IndexingOperations): Promise<{\n        commit: string | undefined;\n    }>;\n    private ensureRepo;\n}\nexport {};\n",
          "indexer.js": "import { Repository, Commit, RepoNotFound } from './lib/git';\nimport Change from './lib/change';\nimport logger from '@cardstack/logger';\nconst log = logger('cardstack/git/indexer');\nimport service from './lib/service';\nconst defaultBranch = 'master';\nimport { extractSettings } from './lib/git-settings';\nimport { assertSingleResourceDoc } from '@cardstack/hub';\nimport merge from 'lodash/merge';\nimport { UpstreamDocument } from '@cardstack/hub';\nimport { inDependencyOrder } from '@cardstack/hub';\nexport default class GitIndexer {\n    constructor(realmCard) {\n        this.realmCard = realmCard;\n        this.basePath = [];\n        this.branchPrefix = '';\n    }\n    async ready() {\n        let settings = await extractSettings(this.realmCard);\n        this.repoPath = settings.repo;\n        this.basePath = settings.basePath ? settings.basePath.split('/') : [];\n        this.branchPrefix = settings.branchPrefix;\n        this.remote = settings.remote;\n    }\n    async update(meta, ops) {\n        log.debug(`starting update()`);\n        await this.ensureRepo();\n        let targetBranch = this.branchPrefix + defaultBranch;\n        if (this.remote) {\n            await service.pullRepo(this.remote.url, targetBranch);\n        }\n        let updater = new GitUpdater(this.realmCard, this.repo, targetBranch, this.basePath);\n        let result = await updater.updateContent(meta, ops);\n        log.debug(`ending update()`);\n        return result;\n    }\n    async ensureRepo() {\n        if (!this.repo) {\n            if (this.remote) {\n                log.info('Getting remote repo for %s from service', this.remote.url);\n                this.repo = await service.getRepo(this.remote.url, this.remote);\n                return;\n            }\n            try {\n                this.repo = await Repository.open(this.repoPath);\n            }\n            catch (e) {\n                if (e instanceof RepoNotFound) {\n                    let change = await Change.createInitial(this.repoPath, 'master');\n                    this.repo = change.repo;\n                    await change.finalize({\n                        message: 'First commit',\n                        authorName: 'Cardstack Hub',\n                        authorEmail: 'hub@cardstack.com',\n                    });\n                }\n                else {\n                    throw e;\n                }\n            }\n        }\n    }\n}\nclass GitUpdater {\n    constructor(realmCard, repo, branch, basePath) {\n        this.realmCard = realmCard;\n        this.repo = repo;\n        this.branch = branch;\n        this.basePath = basePath;\n        this.docsToIndex = new Map();\n    }\n    async updateContent(meta, ops) {\n        log.debug(`starting updateContent()`);\n        await this.loadCommit();\n        let originalTree;\n        if (meta && meta.commit) {\n            try {\n                let oldCommit = await Commit.lookup(this.repo, meta.commit);\n                originalTree = await oldCommit.getTree();\n            }\n            catch (err) {\n                log.warn(`Unable to load previously indexed commit ${meta.commit} due to ${err}. We will recover by reindexing all content.`);\n            }\n        }\n        if (!originalTree) {\n            await ops.beginReplaceAll();\n        }\n        await this.findEntriesToIndex(ops, originalTree, this.rootTree, {\n            only: this.basePath.concat([['cards']]),\n        });\n        let docsInOrder = inDependencyOrder([...this.docsToIndex.keys()], this.realmCard.csId);\n        for (let doc of docsInOrder) {\n            let upstreamId = this.docsToIndex.get(doc);\n            await ops.save(upstreamId, new UpstreamDocument(doc));\n        }\n        if (!originalTree) {\n            await ops.finishReplaceAll();\n        }\n        log.debug(`completed updateContent()`);\n        return {\n            commit: this.commitId,\n        };\n    }\n    async loadCommit() {\n        if (!this.commit) {\n            this.commit = await this.commitAtBranch(this.branch);\n            this.commitId = this.commit.sha();\n        }\n        if (!this.rootTree) {\n            this.rootTree = await this.commit.getTree();\n        }\n    }\n    async commitAtBranch(branchName) {\n        let branch = await this.repo.lookupLocalBranch(branchName);\n        return Commit.lookup(this.repo, branch.target());\n    }\n    async findEntriesToIndex(ops, oldTree, newTree, filter) {\n        let seen = new Map();\n        if (newTree) {\n            for (let newEntry of newTree.entries()) {\n                let name = newEntry.name();\n                if (!filterAllows(filter, name)) {\n                    continue;\n                }\n                seen.set(name, true);\n                await this.collectEntriesToIndex(ops, name, oldTree, newEntry, filter);\n            }\n        }\n        if (oldTree) {\n            for (let oldEntry of oldTree.entries()) {\n                let name = oldEntry.name();\n                if (!filterAllows(filter, name)) {\n                    continue;\n                }\n                if (!seen.get(name)) {\n                    await this.deleteEntry(ops, oldEntry, filter);\n                }\n            }\n        }\n    }\n    async collectEntriesToIndex(ops, name, oldTree, newEntry, filter) {\n        let oldEntry;\n        if (oldTree) {\n            oldEntry = oldTree.entryByName(name);\n            if (oldEntry && oldEntry.id() && oldEntry.id().equal(newEntry.id())) {\n                // We can prune whole subtrees when we find an identical\n                // entry. Which is kinda the point of Git's data\n                // structure in the first place.\n                return;\n            }\n        }\n        if (newEntry.isTree() && (await newEntry.getTree()).entryByName('card.json')) {\n            let cardTree = await newEntry.getTree();\n            let cardEntries = await this.crawlCard(cardTree);\n            // Let's re-index this card since something is different (otherwise the\n            // pruning above would have recocognized that the card subtree was\n            // unchanged).\n            let json = await this.assembleCard(cardTree, cardEntries);\n            let upstreamId = {\n                csId: json.data.attributes.csId,\n                csOriginalRealm: json.data.attributes.csOriginalRealm,\n            };\n            this.docsToIndex.set(json, upstreamId);\n        }\n        else if (newEntry.isTree()) {\n            await this.findEntriesToIndex(ops, oldEntry && oldEntry.isTree() ? await oldEntry.getTree() : undefined, await newEntry.getTree(), nextFilter(filter));\n        }\n    }\n    async deleteEntry(ops, oldEntry, filter) {\n        var _a;\n        if (oldEntry.isTree() && (await oldEntry.getTree()).entryByName('card.json')) {\n            let cardTree = await oldEntry.getTree();\n            let json = await entryToDoc(cardTree.entryByName('card.json'));\n            if ((_a = json) === null || _a === void 0 ? void 0 : _a.data.attributes) {\n                await ops.delete(json.data.attributes);\n            }\n        }\n        else if (oldEntry.isTree()) {\n            await this.findEntriesToIndex(ops, await oldEntry.getTree(), undefined, nextFilter(filter));\n        }\n    }\n    async crawlCard(cardTree) {\n        let output = new Map();\n        for (let entry of cardTree.entries()) {\n            if (entry.isTree()) {\n                output.set(entry.path(), await this.crawlCard(await entry.getTree()));\n            }\n            else {\n                output.set(entry.path(), entry);\n            }\n        }\n        return output;\n    }\n    async assembleCard(cardTree, files) {\n        let pkgEntry = cardTree.entryByName('package.json');\n        if (!pkgEntry || !pkgEntry.isBlob()) {\n            throw new Error(`Card is missing package.json file`);\n        }\n        let pkgContents = await entryToString(pkgEntry);\n        if (!pkgContents) {\n            throw new Error(`Card has empty package.json file`);\n        }\n        let pkg = JSON.parse(pkgContents);\n        let cardJsonEntry = cardTree.entryByName('card.json');\n        if (!cardJsonEntry || !cardJsonEntry.isBlob()) {\n            throw new Error(`Card is missing card.json file`);\n        }\n        let json;\n        try {\n            json = await entryToDoc(cardJsonEntry);\n        }\n        catch (err) {\n            if ('isCardstackError' in err) {\n                throw new Error(`card.json is invalid because: ${err}`);\n            }\n            throw err;\n        }\n        if (!json) {\n            throw new Error(`card.json is empty`);\n        }\n        // ensure we have an attributes object\n        merge(json, {\n            data: {\n                attributes: {},\n            },\n        });\n        // then ensure that csFiles reflects our true on disk files only\n        json.data.attributes.csFiles = await loadFiles(cardTree, '', files, ['package.json', 'card.json']);\n        // and our peerDeps match the ones from package.json\n        // @ts-ignore\n        json.data.attributes.csPeerDependencies = pkg.peerDependencies;\n        return json;\n    }\n}\nasync function loadFiles(cardTree, subDirectory, files, exclude = []) {\n    let output = Object.create(null);\n    let cardDir = cardTree.path();\n    for (let [name, entry] of files) {\n        let csFileName = name.slice(cardDir.length + subDirectory.length + 1);\n        if (exclude.includes(csFileName)) {\n            continue;\n        }\n        if (entry instanceof Map) {\n            output[csFileName] = await loadFiles(cardTree, `${subDirectory}/${csFileName}`, entry);\n        }\n        else {\n            output[csFileName] = (await entryToString(entry)) || '';\n        }\n    }\n    return output;\n}\nasync function entryToString(entry) {\n    if (entry.isBlob()) {\n        return Buffer.from((await entry.getBlob()).content()).toString('utf8');\n    }\n}\nasync function entryToDoc(entry) {\n    let contents = await entryToString(entry);\n    if (contents == null) {\n        return;\n    }\n    let json = JSON.parse(contents);\n    assertSingleResourceDoc(json);\n    return json;\n}\nfunction filterAllows(filter, name) {\n    return (!filter ||\n        !filter.only ||\n        filter.only.length === 0 ||\n        (Array.isArray(filter.only[0]) && filter.only[0].includes(name)) ||\n        name === filter.only[0]);\n}\nfunction nextFilter(filter) {\n    if (!filter || !filter.only || filter.only.length < 2) {\n        return null;\n    }\n    return { only: filter.only.slice(1) };\n}\n//# sourceMappingURL=indexer.js.map",
          "indexer.js.map": "{\"version\":3,\"file\":\"indexer.js\",\"sourceRoot\":\"\",\"sources\":[\"indexer.ts\"],\"names\":[],\"mappings\":\"AAAA,OAAO,EAAE,UAAU,EAAE,MAAM,EAAgB,YAAY,EAAE,MAAM,WAAW,CAAC;AAG3E,OAAO,MAAM,MAAM,cAAc,CAAC;AAClC,OAAO,MAAM,MAAM,mBAAmB,CAAC;AACvC,MAAM,GAAG,GAAG,MAAM,CAAC,uBAAuB,CAAC,CAAC;AAC5C,OAAO,OAAO,MAAM,eAAe,CAAC;AAEpC,MAAM,aAAa,GAAG,QAAQ,CAAC;AAI/B,OAAO,EAAE,eAAe,EAAE,MAAM,oBAAoB,CAAC;AACrD,OAAO,EAAE,uBAAuB,EAAE,MAAM,gBAAgB,CAAC;AAEzD,OAAO,KAAK,MAAM,cAAc,CAAC;AACjC,OAAO,EAAE,gBAAgB,EAAoB,MAAM,gBAAgB,CAAC;AACpE,OAAO,EAAE,iBAAiB,EAAE,MAAM,gBAAgB,CAAC;AAQnD,MAAM,CAAC,OAAO,OAAO,UAAU;IAO7B,YAAoB,SAA0B;QAA1B,cAAS,GAAT,SAAS,CAAiB;QAL9C,aAAQ,GAAe,EAAE,CAAC;QAC1B,iBAAY,GAAG,EAAE,CAAC;IAI+B,CAAC;IAElD,KAAK,CAAC,KAAK;QACT,IAAI,QAAQ,GAAG,MAAM,eAAe,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;QACrD,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC,IAAI,CAAC;QAC9B,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC,QAAQ,CAAC,CAAC,CAAC,QAAQ,CAAC,QAAQ,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC;QACtE,IAAI,CAAC,YAAY,GAAG,QAAQ,CAAC,YAAY,CAAC;QAC1C,IAAI,CAAC,MAAM,GAAG,QAAQ,CAAC,MAAM,CAAC;IAChC,CAAC;IAED,KAAK,CAAC,MAAM,CAAC,IAAa,EAAE,GAAuB;QACjD,GAAG,CAAC,KAAK,CAAC,mBAAmB,CAAC,CAAC;QAC/B,MAAM,IAAI,CAAC,UAAU,EAAE,CAAC;QAExB,IAAI,YAAY,GAAG,IAAI,CAAC,YAAY,GAAG,aAAa,CAAC;QAErD,IAAI,IAAI,CAAC,MAAM,EAAE;YACf,MAAM,OAAO,CAAC,QAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,GAAG,EAAE,YAAY,CAAC,CAAC;SACvD;QAED,IAAI,OAAO,GAAG,IAAI,UAAU,CAAC,IAAI,CAAC,SAAS,EAAE,IAAI,CAAC,IAAK,EAAE,YAAY,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC;QAEtF,IAAI,MAAM,GAAG,MAAM,OAAO,CAAC,aAAa,CAAC,IAAI,EAAE,GAAG,CAAC,CAAC;QACpD,GAAG,CAAC,KAAK,CAAC,iBAAiB,CAAC,CAAC;QAC7B,OAAO,MAAM,CAAC;IAChB,CAAC;IAEO,KAAK,CAAC,UAAU;QACtB,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE;YACd,IAAI,IAAI,CAAC,MAAM,EAAE;gBACf,GAAG,CAAC,IAAI,CAAC,yCAAyC,EAAE,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;gBACrE,IAAI,CAAC,IAAI,GAAG,MAAM,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,GAAG,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC;gBAChE,OAAO;aACR;YAED,IAAI;gBACF,IAAI,CAAC,IAAI,GAAG,MAAM,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,QAAS,CAAC,CAAC;aACnD;YAAC,OAAO,CAAC,EAAE;gBACV,IAAI,CAAC,YAAY,YAAY,EAAE;oBAC7B,IAAI,MAAM,GAAG,MAAM,MAAM,CAAC,aAAa,CAAC,IAAI,CAAC,QAAS,EAAE,QAAQ,CAAC,CAAC;oBAClE,IAAI,CAAC,IAAI,GAAG,MAAM,CAAC,IAAI,CAAC;oBAExB,MAAM,MAAM,CAAC,QAAQ,CAAC;wBACpB,OAAO,EAAE,cAAc;wBACvB,UAAU,EAAE,eAAe;wBAC3B,WAAW,EAAE,mBAAmB;qBACjC,CAAC,CAAC;iBACJ;qBAAM;oBACL,MAAM,CAAC,CAAC;iBACT;aACF;SACF;IACH,CAAC;CACF;AAED,MAAM,UAAU;IAMd,YACW,SAA0B,EAC1B,IAAgB,EAChB,MAAc,EACd,QAAoB;QAHpB,cAAS,GAAT,SAAS,CAAiB;QAC1B,SAAI,GAAJ,IAAI,CAAY;QAChB,WAAM,GAAN,MAAM,CAAQ;QACd,aAAQ,GAAR,QAAQ,CAAY;QAN/B,gBAAW,GAA6C,IAAI,GAAG,EAAE,CAAC;IAO/D,CAAC;IAEJ,KAAK,CAAC,aAAa,CAAC,IAAa,EAAE,GAAuB;QACxD,GAAG,CAAC,KAAK,CAAC,0BAA0B,CAAC,CAAC;QACtC,MAAM,IAAI,CAAC,UAAU,EAAE,CAAC;QACxB,IAAI,YAAY,CAAC;QACjB,IAAI,IAAI,IAAI,IAAI,CAAC,MAAM,EAAE;YACvB,IAAI;gBACF,IAAI,SAAS,GAAG,MAAM,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC;gBAC5D,YAAY,GAAG,MAAM,SAAS,CAAC,OAAO,EAAE,CAAC;aAC1C;YAAC,OAAO,GAAG,EAAE;gBACZ,GAAG,CAAC,IAAI,CACN,4CAA4C,IAAI,CAAC,MAAM,WAAW,GAAG,8CAA8C,CACpH,CAAC;aACH;SACF;QACD,IAAI,CAAC,YAAY,EAAE;YACjB,MAAM,GAAG,CAAC,eAAe,EAAE,CAAC;SAC7B;QACD,MAAM,IAAI,CAAC,kBAAkB,CAAC,GAAG,EAAE,YAAY,EAAE,IAAI,CAAC,QAAQ,EAAE;YAC9D,IAAI,EAAE,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC;SACxC,CAAC,CAAC;QAEH,IAAI,WAAW,GAAG,iBAAiB,CAAC,CAAC,GAAG,IAAI,CAAC,WAAW,CAAC,IAAI,EAAE,CAAC,EAAE,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;QACvF,KAAK,IAAI,GAAG,IAAI,WAAW,EAAE;YAC3B,IAAI,UAAU,GAAG,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;YAC3C,MAAM,GAAG,CAAC,IAAI,CAAC,UAAW,EAAE,IAAI,gBAAgB,CAAC,GAAG,CAAC,CAAC,CAAC;SACxD;QAED,IAAI,CAAC,YAAY,EAAE;YACjB,MAAM,GAAG,CAAC,gBAAgB,EAAE,CAAC;SAC9B;QACD,GAAG,CAAC,KAAK,CAAC,2BAA2B,CAAC,CAAC;QACvC,OAAO;YACL,MAAM,EAAE,IAAI,CAAC,QAAQ;SACtB,CAAC;IACJ,CAAC;IAEO,KAAK,CAAC,UAAU;QACtB,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE;YAChB,IAAI,CAAC,MAAM,GAAG,MAAM,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;YACrD,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,MAAM,CAAC,GAAG,EAAE,CAAC;SACnC;QACD,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE;YAClB,IAAI,CAAC,QAAQ,GAAG,MAAM,IAAI,CAAC,MAAM,CAAC,OAAO,EAAE,CAAC;SAC7C;IACH,CAAC;IAEO,KAAK,CAAC,cAAc,CAAC,UAAkB;QAC7C,IAAI,MAAM,GAAG,MAAM,IAAI,CAAC,IAAI,CAAC,iBAAiB,CAAC,UAAU,CAAC,CAAC;QAC3D,OAAO,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,EAAE,MAAM,CAAC,MAAM,EAAE,CAAC,CAAC;IACnD,CAAC;IAEO,KAAK,CAAC,kBAAkB,CAAC,GAAuB,EAAE,OAAc,EAAE,OAAc,EAAE,MAAsB;QAC9G,IAAI,IAAI,GAAG,IAAI,GAAG,EAAE,CAAC;QACrB,IAAI,OAAO,EAAE;YACX,KAAK,IAAI,QAAQ,IAAI,OAAO,CAAC,OAAO,EAAE,EAAE;gBACtC,IAAI,IAAI,GAAG,QAAQ,CAAC,IAAI,EAAE,CAAC;gBAC3B,IAAI,CAAC,YAAY,CAAC,MAAM,EAAE,IAAI,CAAC,EAAE;oBAC/B,SAAS;iBACV;gBACD,IAAI,CAAC,GAAG,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;gBACrB,MAAM,IAAI,CAAC,qBAAqB,CAAC,GAAG,EAAE,IAAI,EAAE,OAAO,EAAE,QAAQ,EAAE,MAAM,CAAC,CAAC;aACxE;SACF;QACD,IAAI,OAAO,EAAE;YACX,KAAK,IAAI,QAAQ,IAAI,OAAO,CAAC,OAAO,EAAE,EAAE;gBACtC,IAAI,IAAI,GAAG,QAAQ,CAAC,IAAI,EAAE,CAAC;gBAC3B,IAAI,CAAC,YAAY,CAAC,MAAM,EAAE,IAAI,CAAC,EAAE;oBAC/B,SAAS;iBACV;gBACD,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE;oBACnB,MAAM,IAAI,CAAC,WAAW,CAAC,GAAG,EAAE,QAAQ,EAAE,MAAM,CAAC,CAAC;iBAC/C;aACF;SACF;IACH,CAAC;IAEO,KAAK,CAAC,qBAAqB,CACjC,GAAuB,EACvB,IAAY,EACZ,OAAyB,EACzB,QAAmB,EACnB,MAAsB;QAEtB,IAAI,QAAQ,CAAC;QACb,IAAI,OAAO,EAAE;YACX,QAAQ,GAAG,OAAO,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;YACrC,IAAI,QAAQ,IAAI,QAAQ,CAAC,EAAE,EAAE,IAAI,QAAQ,CAAC,EAAE,EAAG,CAAC,KAAK,CAAC,QAAQ,CAAC,EAAE,EAAG,CAAC,EAAE;gBACrE,wDAAwD;gBACxD,gDAAgD;gBAChD,gCAAgC;gBAChC,OAAO;aACR;SACF;QACD,IAAI,QAAQ,CAAC,MAAM,EAAE,IAAI,CAAC,MAAM,QAAQ,CAAC,OAAO,EAAE,CAAC,CAAC,WAAW,CAAC,WAAW,CAAC,EAAE;YAC5E,IAAI,QAAQ,GAAG,MAAM,QAAQ,CAAC,OAAO,EAAE,CAAC;YACxC,IAAI,WAAW,GAAG,MAAM,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,CAAC;YACjD,uEAAuE;YACvE,kEAAkE;YAClE,cAAc;YACd,IAAI,IAAI,GAAG,MAAM,IAAI,CAAC,YAAY,CAAC,QAAQ,EAAE,WAAW,CAAC,CAAC;YAC1D,IAAI,UAAU,GAAG;gBACf,IAAI,EAAE,IAAI,CAAC,IAAI,CAAC,UAAW,CAAC,IAAc;gBAC1C,eAAe,EAAE,IAAI,CAAC,IAAI,CAAC,UAAW,CAAC,eAAyB;aACjE,CAAC;YACF,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,IAAI,EAAE,UAAU,CAAC,CAAC;SACxC;aAAM,IAAI,QAAQ,CAAC,MAAM,EAAE,EAAE;YAC5B,MAAM,IAAI,CAAC,kBAAkB,CAC3B,GAAG,EACH,QAAQ,IAAI,QAAQ,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC,MAAM,QAAQ,CAAC,OAAO,EAAE,CAAC,CAAC,CAAC,SAAS,EACpE,MAAM,QAAQ,CAAC,OAAO,EAAE,EACxB,UAAU,CAAC,MAAM,CAAC,CACnB,CAAC;SACH;IACH,CAAC;IAEO,KAAK,CAAC,WAAW,CAAC,GAAuB,EAAE,QAAmB,EAAE,MAAsB;;QAC5F,IAAI,QAAQ,CAAC,MAAM,EAAE,IAAI,CAAC,MAAM,QAAQ,CAAC,OAAO,EAAE,CAAC,CAAC,WAAW,CAAC,WAAW,CAAC,EAAE;YAC5E,IAAI,QAAQ,GAAG,MAAM,QAAQ,CAAC,OAAO,EAAE,CAAC;YACxC,IAAI,IAAI,GAAG,MAAM,UAAU,CAAC,QAAQ,CAAC,WAAW,CAAC,WAAW,CAAE,CAAC,CAAC;YAChE,UAAI,IAAI,0CAAE,IAAI,CAAC,UAAU,EAAE;gBACzB,MAAM,GAAG,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,UAA8B,CAAC,CAAC;aAC5D;SACF;aAAM,IAAI,QAAQ,CAAC,MAAM,EAAE,EAAE;YAC5B,MAAM,IAAI,CAAC,kBAAkB,CAAC,GAAG,EAAE,MAAM,QAAQ,CAAC,OAAO,EAAE,EAAE,SAAS,EAAE,UAAU,CAAC,MAAM,CAAC,CAAC,CAAC;SAC7F;IACH,CAAC;IAEO,KAAK,CAAC,SAAS,CAAC,QAAc;QACpC,IAAI,MAAM,GAAuB,IAAI,GAAG,EAAE,CAAC;QAC3C,KAAK,IAAI,KAAK,IAAI,QAAQ,CAAC,OAAO,EAAE,EAAE;YACpC,IAAI,KAAK,CAAC,MAAM,EAAE,EAAE;gBAClB,MAAM,CAAC,GAAG,CAAC,KAAK,CAAC,IAAI,EAAE,EAAE,MAAM,IAAI,CAAC,SAAS,CAAC,MAAM,KAAK,CAAC,OAAO,EAAE,CAAC,CAAC,CAAC;aACvE;iBAAM;gBACL,MAAM,CAAC,GAAG,CAAC,KAAK,CAAC,IAAI,EAAE,EAAE,KAAK,CAAC,CAAC;aACjC;SACF;QACD,OAAO,MAAM,CAAC;IAChB,CAAC;IAEO,KAAK,CAAC,YAAY,CAAC,QAAc,EAAE,KAAyB;QAClE,IAAI,QAAQ,GAAG,QAAQ,CAAC,WAAW,CAAC,cAAc,CAAC,CAAC;QACpD,IAAI,CAAC,QAAQ,IAAI,CAAC,QAAQ,CAAC,MAAM,EAAE,EAAE;YACnC,MAAM,IAAI,KAAK,CAAC,mCAAmC,CAAC,CAAC;SACtD;QACD,IAAI,WAAW,GAAG,MAAM,aAAa,CAAC,QAAQ,CAAC,CAAC;QAChD,IAAI,CAAC,WAAW,EAAE;YAChB,MAAM,IAAI,KAAK,CAAC,kCAAkC,CAAC,CAAC;SACrD;QACD,IAAI,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,WAAW,CAAC,CAAC;QAElC,IAAI,aAAa,GAAG,QAAQ,CAAC,WAAW,CAAC,WAAW,CAAC,CAAC;QACtD,IAAI,CAAC,aAAa,IAAI,CAAC,aAAa,CAAC,MAAM,EAAE,EAAE;YAC7C,MAAM,IAAI,KAAK,CAAC,gCAAgC,CAAC,CAAC;SACnD;QACD,IAAI,IAAI,CAAC;QACT,IAAI;YACF,IAAI,GAAG,MAAM,UAAU,CAAC,aAAa,CAAC,CAAC;SACxC;QAAC,OAAO,GAAG,EAAE;YACZ,IAAI,kBAAkB,IAAI,GAAG,EAAE;gBAC7B,MAAM,IAAI,KAAK,CAAC,iCAAiC,GAAG,EAAE,CAAC,CAAC;aACzD;YACD,MAAM,GAAG,CAAC;SACX;QACD,IAAI,CAAC,IAAI,EAAE;YACT,MAAM,IAAI,KAAK,CAAC,oBAAoB,CAAC,CAAC;SACvC;QAED,sCAAsC;QACtC,KAAK,CAAC,IAAI,EAAE;YACV,IAAI,EAAE;gBACJ,UAAU,EAAE,EAAE;aACf;SACF,CAAC,CAAC;QAEH,gEAAgE;QAChE,IAAI,CAAC,IAAI,CAAC,UAAW,CAAC,OAAO,GAAG,MAAM,SAAS,CAAC,QAAQ,EAAE,EAAE,EAAE,KAAK,EAAE,CAAC,cAAc,EAAE,WAAW,CAAC,CAAC,CAAC;QAEpG,oDAAoD;QACpD,aAAa;QACb,IAAI,CAAC,IAAI,CAAC,UAAW,CAAC,kBAAkB,GAAG,GAAG,CAAC,gBAAgB,CAAC;QAChE,OAAO,IAAI,CAAC;IACd,CAAC;CACF;AAID,KAAK,UAAU,SAAS,CACtB,QAAc,EACd,YAAoB,EACpB,KAAyB,EACzB,UAAoB,EAAE;IAEtB,IAAI,MAAM,GAAiC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;IAC/D,IAAI,OAAO,GAAG,QAAQ,CAAC,IAAI,EAAE,CAAC;IAC9B,KAAK,IAAI,CAAC,IAAI,EAAE,KAAK,CAAC,IAAI,KAAK,EAAE;QAC/B,IAAI,UAAU,GAAG,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,MAAM,GAAG,YAAY,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;QACtE,IAAI,OAAO,CAAC,QAAQ,CAAC,UAAU,CAAC,EAAE;YAChC,SAAS;SACV;QACD,IAAI,KAAK,YAAY,GAAG,EAAE;YACxB,MAAM,CAAC,UAAU,CAAC,GAAG,MAAM,SAAS,CAAC,QAAQ,EAAE,GAAG,YAAY,IAAI,UAAU,EAAE,EAAE,KAAK,CAAC,CAAC;SACxF;aAAM;YACL,MAAM,CAAC,UAAU,CAAC,GAAG,CAAC,MAAM,aAAa,CAAC,KAAK,CAAC,CAAC,IAAI,EAAE,CAAC;SACzD;KACF;IACD,OAAO,MAAM,CAAC;AAChB,CAAC;AAED,KAAK,UAAU,aAAa,CAAC,KAAgB;IAC3C,IAAI,KAAK,CAAC,MAAM,EAAE,EAAE;QAClB,OAAO,MAAM,CAAC,IAAI,CAAC,CAAC,MAAM,KAAK,CAAC,OAAO,EAAE,CAAC,CAAC,OAAO,EAAE,CAAC,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC;KACxE;AACH,CAAC;AACD,KAAK,UAAU,UAAU,CAAC,KAAgB;IACxC,IAAI,QAAQ,GAAG,MAAM,aAAa,CAAC,KAAK,CAAC,CAAC;IAC1C,IAAI,QAAQ,IAAI,IAAI,EAAE;QACpB,OAAO;KACR;IAED,IAAI,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC;IAChC,uBAAuB,CAAC,IAAI,CAAC,CAAC;IAC9B,OAAO,IAAI,CAAC;AACd,CAAC;AAMD,SAAS,YAAY,CAAC,MAAiC,EAAE,IAAY;IACnE,OAAO,CACL,CAAC,MAAM;QACP,CAAC,MAAM,CAAC,IAAI;QACZ,MAAM,CAAC,IAAI,CAAC,MAAM,KAAK,CAAC;QACxB,CAAC,KAAK,CAAC,OAAO,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,IAAI,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;QAChE,IAAI,KAAK,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CACxB,CAAC;AACJ,CAAC;AAED,SAAS,UAAU,CAAC,MAAiC;IACnD,IAAI,CAAC,MAAM,IAAI,CAAC,MAAM,CAAC,IAAI,IAAI,MAAM,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,EAAE;QACrD,OAAO,IAAI,CAAC;KACb;IACD,OAAO,EAAE,IAAI,EAAE,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC;AACxC,CAAC\"}",
          "indexer.ts": "import { Repository, Commit, RemoteConfig, RepoNotFound } from './lib/git';\nimport Tree, { TreeEntry } from './lib/tree';\n\nimport Change from './lib/change';\nimport logger from '@cardstack/logger';\nconst log = logger('cardstack/git/indexer');\nimport service from './lib/service';\n\nconst defaultBranch = 'master';\n\nimport { Indexer, IndexingOperations } from '@cardstack/hub';\nimport { AddressableCard, Card } from '@cardstack/hub';\nimport { extractSettings } from './lib/git-settings';\nimport { assertSingleResourceDoc } from '@cardstack/hub';\nimport { SingleResourceDoc } from 'jsonapi-typescript';\nimport merge from 'lodash/merge';\nimport { UpstreamDocument, UpstreamIdentity } from '@cardstack/hub';\nimport { inDependencyOrder } from '@cardstack/hub';\n\ninterface GitMeta {\n  commit?: string;\n}\n\ntype PathSpec = string | string[];\n\nexport default class GitIndexer implements Indexer<GitMeta> {\n  repoPath?: string;\n  basePath: PathSpec[] = [];\n  branchPrefix = '';\n  remote?: RemoteConfig;\n  repo?: Repository;\n\n  constructor(private realmCard: AddressableCard) {}\n\n  async ready(): Promise<void> {\n    let settings = await extractSettings(this.realmCard);\n    this.repoPath = settings.repo;\n    this.basePath = settings.basePath ? settings.basePath.split('/') : [];\n    this.branchPrefix = settings.branchPrefix;\n    this.remote = settings.remote;\n  }\n\n  async update(meta: GitMeta, ops: IndexingOperations) {\n    log.debug(`starting update()`);\n    await this.ensureRepo();\n\n    let targetBranch = this.branchPrefix + defaultBranch;\n\n    if (this.remote) {\n      await service.pullRepo(this.remote.url, targetBranch);\n    }\n\n    let updater = new GitUpdater(this.realmCard, this.repo!, targetBranch, this.basePath);\n\n    let result = await updater.updateContent(meta, ops);\n    log.debug(`ending update()`);\n    return result;\n  }\n\n  private async ensureRepo() {\n    if (!this.repo) {\n      if (this.remote) {\n        log.info('Getting remote repo for %s from service', this.remote.url);\n        this.repo = await service.getRepo(this.remote.url, this.remote);\n        return;\n      }\n\n      try {\n        this.repo = await Repository.open(this.repoPath!);\n      } catch (e) {\n        if (e instanceof RepoNotFound) {\n          let change = await Change.createInitial(this.repoPath!, 'master');\n          this.repo = change.repo;\n\n          await change.finalize({\n            message: 'First commit',\n            authorName: 'Cardstack Hub',\n            authorEmail: 'hub@cardstack.com',\n          });\n        } else {\n          throw e;\n        }\n      }\n    }\n  }\n}\n\nclass GitUpdater {\n  commit?: Commit;\n  commitId?: string;\n  rootTree?: Tree;\n  docsToIndex: Map<SingleResourceDoc, UpstreamIdentity> = new Map();\n\n  constructor(\n    readonly realmCard: AddressableCard,\n    readonly repo: Repository,\n    readonly branch: string,\n    readonly basePath: PathSpec[]\n  ) {}\n\n  async updateContent(meta: GitMeta, ops: IndexingOperations) {\n    log.debug(`starting updateContent()`);\n    await this.loadCommit();\n    let originalTree;\n    if (meta && meta.commit) {\n      try {\n        let oldCommit = await Commit.lookup(this.repo, meta.commit);\n        originalTree = await oldCommit.getTree();\n      } catch (err) {\n        log.warn(\n          `Unable to load previously indexed commit ${meta.commit} due to ${err}. We will recover by reindexing all content.`\n        );\n      }\n    }\n    if (!originalTree) {\n      await ops.beginReplaceAll();\n    }\n    await this.findEntriesToIndex(ops, originalTree, this.rootTree, {\n      only: this.basePath.concat([['cards']]),\n    });\n\n    let docsInOrder = inDependencyOrder([...this.docsToIndex.keys()], this.realmCard.csId);\n    for (let doc of docsInOrder) {\n      let upstreamId = this.docsToIndex.get(doc);\n      await ops.save(upstreamId!, new UpstreamDocument(doc));\n    }\n\n    if (!originalTree) {\n      await ops.finishReplaceAll();\n    }\n    log.debug(`completed updateContent()`);\n    return {\n      commit: this.commitId,\n    };\n  }\n\n  private async loadCommit() {\n    if (!this.commit) {\n      this.commit = await this.commitAtBranch(this.branch);\n      this.commitId = this.commit.sha();\n    }\n    if (!this.rootTree) {\n      this.rootTree = await this.commit.getTree();\n    }\n  }\n\n  private async commitAtBranch(branchName: string) {\n    let branch = await this.repo.lookupLocalBranch(branchName);\n    return Commit.lookup(this.repo, branch.target());\n  }\n\n  private async findEntriesToIndex(ops: IndexingOperations, oldTree?: Tree, newTree?: Tree, filter?: Filter | null) {\n    let seen = new Map();\n    if (newTree) {\n      for (let newEntry of newTree.entries()) {\n        let name = newEntry.name();\n        if (!filterAllows(filter, name)) {\n          continue;\n        }\n        seen.set(name, true);\n        await this.collectEntriesToIndex(ops, name, oldTree, newEntry, filter);\n      }\n    }\n    if (oldTree) {\n      for (let oldEntry of oldTree.entries()) {\n        let name = oldEntry.name();\n        if (!filterAllows(filter, name)) {\n          continue;\n        }\n        if (!seen.get(name)) {\n          await this.deleteEntry(ops, oldEntry, filter);\n        }\n      }\n    }\n  }\n\n  private async collectEntriesToIndex(\n    ops: IndexingOperations,\n    name: string,\n    oldTree: Tree | undefined,\n    newEntry: TreeEntry,\n    filter?: Filter | null\n  ) {\n    let oldEntry;\n    if (oldTree) {\n      oldEntry = oldTree.entryByName(name);\n      if (oldEntry && oldEntry.id() && oldEntry.id()!.equal(newEntry.id()!)) {\n        // We can prune whole subtrees when we find an identical\n        // entry. Which is kinda the point of Git's data\n        // structure in the first place.\n        return;\n      }\n    }\n    if (newEntry.isTree() && (await newEntry.getTree()).entryByName('card.json')) {\n      let cardTree = await newEntry.getTree();\n      let cardEntries = await this.crawlCard(cardTree);\n      // Let's re-index this card since something is different (otherwise the\n      // pruning above would have recocognized that the card subtree was\n      // unchanged).\n      let json = await this.assembleCard(cardTree, cardEntries);\n      let upstreamId = {\n        csId: json.data.attributes!.csId as string,\n        csOriginalRealm: json.data.attributes!.csOriginalRealm as string,\n      };\n      this.docsToIndex.set(json, upstreamId);\n    } else if (newEntry.isTree()) {\n      await this.findEntriesToIndex(\n        ops,\n        oldEntry && oldEntry.isTree() ? await oldEntry.getTree() : undefined,\n        await newEntry.getTree(),\n        nextFilter(filter)\n      );\n    }\n  }\n\n  private async deleteEntry(ops: IndexingOperations, oldEntry: TreeEntry, filter?: Filter | null) {\n    if (oldEntry.isTree() && (await oldEntry.getTree()).entryByName('card.json')) {\n      let cardTree = await oldEntry.getTree();\n      let json = await entryToDoc(cardTree.entryByName('card.json')!);\n      if (json?.data.attributes) {\n        await ops.delete(json.data.attributes as UpstreamIdentity);\n      }\n    } else if (oldEntry.isTree()) {\n      await this.findEntriesToIndex(ops, await oldEntry.getTree(), undefined, nextFilter(filter));\n    }\n  }\n\n  private async crawlCard(cardTree: Tree): Promise<Map<string, Entry>> {\n    let output: Map<string, Entry> = new Map();\n    for (let entry of cardTree.entries()) {\n      if (entry.isTree()) {\n        output.set(entry.path(), await this.crawlCard(await entry.getTree()));\n      } else {\n        output.set(entry.path(), entry);\n      }\n    }\n    return output;\n  }\n\n  private async assembleCard(cardTree: Tree, files: Map<string, Entry>): Promise<SingleResourceDoc> {\n    let pkgEntry = cardTree.entryByName('package.json');\n    if (!pkgEntry || !pkgEntry.isBlob()) {\n      throw new Error(`Card is missing package.json file`);\n    }\n    let pkgContents = await entryToString(pkgEntry);\n    if (!pkgContents) {\n      throw new Error(`Card has empty package.json file`);\n    }\n    let pkg = JSON.parse(pkgContents);\n\n    let cardJsonEntry = cardTree.entryByName('card.json');\n    if (!cardJsonEntry || !cardJsonEntry.isBlob()) {\n      throw new Error(`Card is missing card.json file`);\n    }\n    let json;\n    try {\n      json = await entryToDoc(cardJsonEntry);\n    } catch (err) {\n      if ('isCardstackError' in err) {\n        throw new Error(`card.json is invalid because: ${err}`);\n      }\n      throw err;\n    }\n    if (!json) {\n      throw new Error(`card.json is empty`);\n    }\n\n    // ensure we have an attributes object\n    merge(json, {\n      data: {\n        attributes: {},\n      },\n    });\n\n    // then ensure that csFiles reflects our true on disk files only\n    json.data.attributes!.csFiles = await loadFiles(cardTree, '', files, ['package.json', 'card.json']);\n\n    // and our peerDeps match the ones from package.json\n    // @ts-ignore\n    json.data.attributes!.csPeerDependencies = pkg.peerDependencies;\n    return json;\n  }\n}\n\ntype Entry = TreeEntry | Map<string, Entry>;\n\nasync function loadFiles(\n  cardTree: Tree,\n  subDirectory: string,\n  files: Map<string, Entry>,\n  exclude: string[] = []\n): Promise<NonNullable<Card['csFiles']>> {\n  let output: NonNullable<Card['csFiles']> = Object.create(null);\n  let cardDir = cardTree.path();\n  for (let [name, entry] of files) {\n    let csFileName = name.slice(cardDir.length + subDirectory.length + 1);\n    if (exclude.includes(csFileName)) {\n      continue;\n    }\n    if (entry instanceof Map) {\n      output[csFileName] = await loadFiles(cardTree, `${subDirectory}/${csFileName}`, entry);\n    } else {\n      output[csFileName] = (await entryToString(entry)) || '';\n    }\n  }\n  return output;\n}\n\nasync function entryToString(entry: TreeEntry): Promise<string | undefined> {\n  if (entry.isBlob()) {\n    return Buffer.from((await entry.getBlob()).content()).toString('utf8');\n  }\n}\nasync function entryToDoc(entry: TreeEntry): Promise<SingleResourceDoc | undefined> {\n  let contents = await entryToString(entry);\n  if (contents == null) {\n    return;\n  }\n\n  let json = JSON.parse(contents);\n  assertSingleResourceDoc(json);\n  return json;\n}\n\ninterface Filter {\n  only: PathSpec | PathSpec[];\n}\n\nfunction filterAllows(filter: Filter | null | undefined, name: string) {\n  return (\n    !filter ||\n    !filter.only ||\n    filter.only.length === 0 ||\n    (Array.isArray(filter.only[0]) && filter.only[0].includes(name)) ||\n    name === filter.only[0]\n  );\n}\n\nfunction nextFilter(filter: Filter | undefined | null) {\n  if (!filter || !filter.only || filter.only.length < 2) {\n    return null;\n  }\n  return { only: filter.only.slice(1) };\n}\n",
          "lib": {
            "change.d.ts": "/// <reference types=\"node\" />\nimport { Commit, Repository, CommitOpts, Oid } from './git';\nimport Tree, { TreeEntry, FILEMODE } from './tree';\nexport default class Change {\n    repo: Repository;\n    targetBranch: string;\n    parentTree: Tree | undefined;\n    parents: Commit[];\n    parentCommit?: Commit | undefined;\n    static createInitial(repoPath: string, targetBranch: string): Promise<Change>;\n    static createBranch(repo: Repository, parentId: string, targetBranch: string): Promise<Change>;\n    static create(repo: Repository, parentId: string | null, targetBranch: string, isRemote?: boolean): Promise<Change>;\n    root: Tree;\n    isRemote: boolean;\n    constructor(repo: Repository, targetBranch: string, parentTree: Tree | undefined, parents: Commit[], parentCommit?: Commit | undefined, isRemote?: boolean);\n    private headCommit;\n    get(path: string, { allowCreate, allowUpdate }?: {\n        allowCreate?: boolean;\n        allowUpdate?: boolean;\n    }): Promise<FileHandle>;\n    finalize(commitOpts: CommitOpts): Promise<string>;\n    private makeCommit;\n    private pushCommit;\n    private makeMergeCommit;\n    private applyCommit;\n    private newBranch;\n}\nexport declare class FileHandle {\n    tree: Tree;\n    leaf: TreeEntry | undefined;\n    name: string;\n    allowUpdate: boolean;\n    path: string;\n    mode: FILEMODE;\n    constructor(tree: Tree, leaf: TreeEntry | undefined, name: string, allowUpdate: boolean, path: string);\n    getBuffer(): Promise<Uint8Array | undefined>;\n    exists(): boolean;\n    setContent(buffer: Buffer | string): void;\n    delete(): void;\n    savedId(): Oid | undefined;\n}\n",
            "change.js": "import { Commit, Merge, Repository, BranchNotFound } from './git';\nimport Tree, { FileNotFound, OverwriteRejected } from './tree';\nimport crypto from 'crypto';\nimport delay from 'delay';\nimport logger from '@cardstack/logger';\nconst log = logger('cardstack/git');\nexport default class Change {\n    constructor(repo, targetBranch, parentTree, parents, parentCommit, isRemote) {\n        this.repo = repo;\n        this.targetBranch = targetBranch;\n        this.parentTree = parentTree;\n        this.parents = parents;\n        this.parentCommit = parentCommit;\n        this.repo = repo;\n        this.root = parentTree || Tree.create(repo, parentTree);\n        this.isRemote = !!isRemote;\n    }\n    static async createInitial(repoPath, targetBranch) {\n        let repo = await Repository.initBare(repoPath);\n        return new this(repo, targetBranch, undefined, []);\n    }\n    static async createBranch(repo, parentId, targetBranch) {\n        let parentCommit;\n        if (parentId) {\n            parentCommit = await Commit.lookup(repo, parentId);\n        }\n        let parentTree;\n        let parents = [];\n        if (parentCommit) {\n            parentTree = await parentCommit.getTree();\n            parents.push(parentCommit);\n        }\n        return new this(repo, targetBranch, parentTree, parents, parentCommit);\n    }\n    static async create(repo, parentId, targetBranch, isRemote) {\n        let parentCommit;\n        if (parentId) {\n            parentCommit = await Commit.lookup(repo, parentId);\n        }\n        else {\n            parentCommit = await headCommit(repo, targetBranch, !!isRemote);\n        }\n        let parentTree;\n        let parents = [];\n        if (parentCommit) {\n            parentTree = await parentCommit.getTree();\n            parents.push(parentCommit);\n        }\n        return new this(repo, targetBranch, parentTree, parents, parentCommit, isRemote);\n    }\n    async headCommit() {\n        return headCommit(this.repo, this.targetBranch, this.isRemote);\n    }\n    async get(path, { allowCreate, allowUpdate } = {}) {\n        let { tree, leaf, leafName } = await this.root.fileAtPath(path, !!allowCreate);\n        return new FileHandle(tree, leaf, leafName, !!allowUpdate, path);\n    }\n    async finalize(commitOpts) {\n        let newCommit = await this.makeCommit(commitOpts);\n        let delayTime = 500;\n        let mergeCommit;\n        let needsFetchAll = false;\n        while (delayTime <= 5000) {\n            mergeCommit = await this.makeMergeCommit(newCommit, commitOpts);\n            try {\n                if (this.isRemote) {\n                    // needsFetchAll only gets set to true if the retry block has failed once\n                    if (needsFetchAll) {\n                        // pull remote before allowing process to continue, allowing us to\n                        // (hopefully) recover from upstream getting out of sync\n                        await this.repo.fetchAll();\n                    }\n                    await this.pushCommit(mergeCommit);\n                }\n                else {\n                    await this.applyCommit(mergeCommit);\n                }\n            }\n            catch (err) {\n                log.warn('Failed to finalize commit \"%s\"', err);\n                needsFetchAll = true;\n                await delay(delayTime);\n                delayTime *= 2;\n                continue;\n            }\n            if (this.isRemote && !this.repo.isBare()) {\n                await this.repo.fetchAll();\n                await this.repo.mergeBranches(this.targetBranch, `origin/${this.targetBranch}`);\n            }\n            return mergeCommit.id().toString();\n        }\n        throw new Error('Failed to finalise commit and could not recover. ');\n    }\n    async makeCommit(commitOpts) {\n        if (!this.root.dirty) {\n            return this.parentCommit;\n        }\n        let treeOid = await this.root.write(true);\n        let tree = await Tree.lookup(this.repo, treeOid);\n        let commitOid = await Commit.create(this.repo, commitOpts, tree, this.parents);\n        return Commit.lookup(this.repo, commitOid);\n    }\n    async pushCommit(mergeCommit) {\n        const remoteBranchName = `temp-remote-${crypto.randomBytes(20).toString('hex')}`;\n        await this.repo.createBranch(remoteBranchName, mergeCommit);\n        let remote = await this.repo.getRemote('origin');\n        try {\n            await remote.push(`refs/heads/${remoteBranchName}`, `refs/heads/${this.targetBranch}`, { force: true });\n        }\n        catch (err) {\n            // pull remote before allowing process to continue\n            await this.repo.fetchAll();\n            throw err;\n        }\n    }\n    async makeMergeCommit(newCommit, commitOpts) {\n        let headCommit = await this.headCommit();\n        if (!headCommit) {\n            // new branch, so no merge needed\n            return newCommit;\n        }\n        let baseOid = await Merge.base(this.repo, newCommit.id(), headCommit.id());\n        if (baseOid.equal(headCommit.id())) {\n            // fast forward (we think), so no merge needed\n            return newCommit;\n        }\n        commitOpts.message = `Clean merge into ${this.targetBranch}`;\n        let mergeResult = await Merge.perform(this.repo, newCommit, headCommit, commitOpts);\n        return await Commit.lookup(this.repo, mergeResult.oid);\n    }\n    async applyCommit(commit) {\n        let headCommit = await this.headCommit();\n        if (!headCommit) {\n            return await this.newBranch(commit);\n        }\n        let headRef = await this.repo.lookupLocalBranch(this.targetBranch);\n        await headRef.setTarget(commit.id());\n    }\n    async newBranch(newCommit) {\n        await this.repo.createBranch(this.targetBranch, newCommit);\n    }\n}\nexport class FileHandle {\n    constructor(tree, leaf, name, allowUpdate, path) {\n        this.tree = tree;\n        this.leaf = leaf;\n        this.name = name;\n        this.allowUpdate = allowUpdate;\n        this.path = path;\n        this.tree = tree;\n        this.leaf = leaf;\n        this.name = name;\n        this.allowUpdate = allowUpdate;\n        this.path = path;\n        if (leaf) {\n            this.mode = leaf.filemode();\n        }\n        else {\n            this.mode = \"100644\" /* BLOB */;\n        }\n    }\n    async getBuffer() {\n        if (this.leaf) {\n            return (await this.leaf.getBlob()).content();\n        }\n    }\n    exists() {\n        return !!this.leaf;\n    }\n    setContent(buffer) {\n        if (typeof buffer === 'string') {\n            buffer = Buffer.from(buffer, 'utf8');\n        }\n        if (!(buffer instanceof Buffer)) {\n            throw new Error('setContent got something that was not a Buffer or String');\n        }\n        if (!this.allowUpdate && this.leaf) {\n            throw new OverwriteRejected(`Refusing to overwrite ${this.path}`);\n        }\n        this.leaf = this.tree.insert(this.name, buffer, this.mode);\n    }\n    delete() {\n        if (!this.leaf) {\n            throw new FileNotFound(`No such file ${this.path}`);\n        }\n        this.tree.delete(this.name);\n        this.leaf = undefined;\n    }\n    savedId() {\n        // this is available only after our change has been finalized\n        return this.leaf && this.leaf.id();\n    }\n}\nmodule.exports = Change;\nasync function headCommit(repo, targetBranch, isRemote) {\n    let headRef;\n    try {\n        if (isRemote) {\n            headRef = await repo.lookupRemoteBranch('origin', targetBranch);\n        }\n        else {\n            headRef = await repo.lookupLocalBranch(targetBranch);\n        }\n    }\n    catch (err) {\n        if (err.constructor !== BranchNotFound) {\n            throw err;\n        }\n    }\n    if (headRef) {\n        return await Commit.lookup(repo, headRef.target());\n    }\n}\n//# sourceMappingURL=change.js.map",
            "change.js.map": "{\"version\":3,\"file\":\"change.js\",\"sourceRoot\":\"\",\"sources\":[\"change.ts\"],\"names\":[],\"mappings\":\"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\"}",
            "change.ts": "import { Commit, Merge, Repository, CommitOpts, BranchNotFound, Oid } from './git';\nimport Tree, { TreeEntry, FileNotFound, OverwriteRejected, FILEMODE } from './tree';\n\nimport crypto from 'crypto';\nimport delay from 'delay';\nimport logger from '@cardstack/logger';\nconst log = logger('cardstack/git');\n\nexport default class Change {\n  static async createInitial(repoPath: string, targetBranch: string) {\n    let repo = await Repository.initBare(repoPath);\n    return new this(repo, targetBranch, undefined, []);\n  }\n\n  static async createBranch(repo: Repository, parentId: string, targetBranch: string) {\n    let parentCommit;\n    if (parentId) {\n      parentCommit = await Commit.lookup(repo, parentId);\n    }\n\n    let parentTree;\n    let parents = [];\n    if (parentCommit) {\n      parentTree = await parentCommit.getTree();\n      parents.push(parentCommit);\n    }\n    return new this(repo, targetBranch, parentTree, parents, parentCommit);\n  }\n\n  static async create(repo: Repository, parentId: string | null, targetBranch: string, isRemote?: boolean) {\n    let parentCommit;\n    if (parentId) {\n      parentCommit = await Commit.lookup(repo, parentId);\n    } else {\n      parentCommit = await headCommit(repo, targetBranch, !!isRemote);\n    }\n\n    let parentTree;\n    let parents = [];\n    if (parentCommit) {\n      parentTree = await parentCommit.getTree();\n      parents.push(parentCommit);\n    }\n    return new this(repo, targetBranch, parentTree, parents, parentCommit, isRemote);\n  }\n\n  root: Tree;\n  isRemote: boolean;\n\n  constructor(\n    public repo: Repository,\n    public targetBranch: string,\n    public parentTree: Tree | undefined,\n    public parents: Commit[],\n    public parentCommit?: Commit,\n    isRemote?: boolean\n  ) {\n    this.repo = repo;\n    this.root = parentTree || Tree.create(repo, parentTree);\n    this.isRemote = !!isRemote;\n  }\n\n  private async headCommit() {\n    return headCommit(this.repo, this.targetBranch, this.isRemote);\n  }\n\n  async get(path: string, { allowCreate, allowUpdate }: { allowCreate?: boolean; allowUpdate?: boolean } = {}) {\n    let { tree, leaf, leafName } = await this.root.fileAtPath(path, !!allowCreate);\n    return new FileHandle(tree, leaf, leafName, !!allowUpdate, path);\n  }\n\n  async finalize(commitOpts: CommitOpts) {\n    let newCommit = await this.makeCommit(commitOpts);\n\n    let delayTime = 500;\n    let mergeCommit;\n    let needsFetchAll = false;\n\n    while (delayTime <= 5000) {\n      mergeCommit = await this.makeMergeCommit(newCommit!, commitOpts);\n\n      try {\n        if (this.isRemote) {\n          // needsFetchAll only gets set to true if the retry block has failed once\n          if (needsFetchAll) {\n            // pull remote before allowing process to continue, allowing us to\n            // (hopefully) recover from upstream getting out of sync\n            await this.repo.fetchAll();\n          }\n          await this.pushCommit(mergeCommit);\n        } else {\n          await this.applyCommit(mergeCommit);\n        }\n      } catch (err) {\n        log.warn('Failed to finalize commit \"%s\"', err);\n        needsFetchAll = true;\n\n        await delay(delayTime);\n        delayTime *= 2;\n\n        continue;\n      }\n\n      if (this.isRemote && !this.repo.isBare()) {\n        await this.repo.fetchAll();\n        await this.repo.mergeBranches(this.targetBranch, `origin/${this.targetBranch}`);\n      }\n\n      return mergeCommit.id().toString();\n    }\n\n    throw new Error('Failed to finalise commit and could not recover. ');\n  }\n\n  private async makeCommit(commitOpts: CommitOpts) {\n    if (!this.root.dirty) {\n      return this.parentCommit;\n    }\n    let treeOid = await this.root.write(true);\n\n    let tree = await Tree.lookup(this.repo, treeOid!);\n    let commitOid = await Commit.create(this.repo, commitOpts, tree, this.parents);\n\n    return Commit.lookup(this.repo, commitOid);\n  }\n\n  private async pushCommit(mergeCommit: Commit) {\n    const remoteBranchName = `temp-remote-${crypto.randomBytes(20).toString('hex')}`;\n    await this.repo.createBranch(remoteBranchName, mergeCommit);\n\n    let remote = await this.repo.getRemote('origin');\n\n    try {\n      await remote.push(`refs/heads/${remoteBranchName}`, `refs/heads/${this.targetBranch}`, { force: true });\n    } catch (err) {\n      // pull remote before allowing process to continue\n      await this.repo.fetchAll();\n      throw err;\n    }\n  }\n\n  private async makeMergeCommit(newCommit: Commit, commitOpts: CommitOpts) {\n    let headCommit = await this.headCommit();\n\n    if (!headCommit) {\n      // new branch, so no merge needed\n      return newCommit;\n    }\n    let baseOid = await Merge.base(this.repo, newCommit.id(), headCommit.id());\n    if (baseOid.equal(headCommit.id())) {\n      // fast forward (we think), so no merge needed\n      return newCommit;\n    }\n\n    commitOpts.message = `Clean merge into ${this.targetBranch}`;\n\n    let mergeResult = await Merge.perform(this.repo, newCommit, headCommit, commitOpts);\n\n    return await Commit.lookup(this.repo, mergeResult.oid!);\n  }\n\n  private async applyCommit(commit: Commit) {\n    let headCommit = await this.headCommit();\n\n    if (!headCommit) {\n      return await this.newBranch(commit);\n    }\n\n    let headRef = await this.repo.lookupLocalBranch(this.targetBranch);\n    await headRef.setTarget(commit.id());\n  }\n\n  private async newBranch(newCommit: Commit) {\n    await this.repo.createBranch(this.targetBranch, newCommit);\n  }\n}\n\nexport class FileHandle {\n  public mode: FILEMODE;\n\n  constructor(\n    public tree: Tree,\n    public leaf: TreeEntry | undefined,\n    public name: string,\n    public allowUpdate: boolean,\n    public path: string\n  ) {\n    this.tree = tree;\n    this.leaf = leaf;\n    this.name = name;\n    this.allowUpdate = allowUpdate;\n    this.path = path;\n    if (leaf) {\n      this.mode = leaf.filemode();\n    } else {\n      this.mode = FILEMODE.BLOB;\n    }\n  }\n  async getBuffer() {\n    if (this.leaf) {\n      return (await this.leaf!.getBlob()!).content();\n    }\n  }\n  exists() {\n    return !!this.leaf;\n  }\n  setContent(buffer: Buffer | string) {\n    if (typeof buffer === 'string') {\n      buffer = Buffer.from(buffer, 'utf8');\n    }\n    if (!(buffer instanceof Buffer)) {\n      throw new Error('setContent got something that was not a Buffer or String');\n    }\n    if (!this.allowUpdate && this.leaf) {\n      throw new OverwriteRejected(`Refusing to overwrite ${this.path}`);\n    }\n    this.leaf = this.tree.insert(this.name, buffer, this.mode);\n  }\n  delete() {\n    if (!this.leaf) {\n      throw new FileNotFound(`No such file ${this.path}`);\n    }\n    this.tree.delete(this.name);\n    this.leaf = undefined;\n  }\n  savedId(): Oid | undefined {\n    // this is available only after our change has been finalized\n    return this.leaf && this.leaf.id()!;\n  }\n}\n\nmodule.exports = Change;\n\nasync function headCommit(repo: Repository, targetBranch: string, isRemote: boolean) {\n  let headRef;\n  try {\n    if (isRemote) {\n      headRef = await repo.lookupRemoteBranch('origin', targetBranch);\n    } else {\n      headRef = await repo.lookupLocalBranch(targetBranch);\n    }\n  } catch (err) {\n    if (err.constructor !== BranchNotFound) {\n      throw err;\n    }\n  }\n  if (headRef) {\n    return await Commit.lookup(repo, headRef.target());\n  }\n}\n",
            "git-settings.d.ts": "interface IndexerSettings {\n    repo?: string;\n    basePath: string;\n    branchPrefix: string;\n    remote?: RemoteConfig;\n}\nimport { RemoteConfig } from './git';\nimport { AddressableCard } from '@cardstack/hub';\nexport declare function extractSettings(realmCard: AddressableCard): Promise<IndexerSettings>;\nexport {};\n",
            "git-settings.js": "import { homedir } from 'os';\nimport { join } from 'path';\nimport { mkdirp } from 'fs-extra';\nimport { Error } from '@cardstack/hub';\nexport async function extractSettings(realmCard) {\n    var _a, _b, _c, _d, _e;\n    // In order to allow git realm cards to be portable, let's let the hub decide\n    // where the repo dir, as the root dir in one hub may not exist in another hub.\n    const repoRootDir = process.env.REPO_ROOT_DIR || join(homedir(), '.cardstack');\n    let repo = (_a = (await realmCard.value('repo')), (_a !== null && _a !== void 0 ? _a : undefined));\n    let remoteUrl = (_b = (await realmCard.value('remoteUrl')), (_b !== null && _b !== void 0 ? _b : undefined));\n    let remoteCacheDir = (_c = (await realmCard.value('remoteCacheDir')), (_c !== null && _c !== void 0 ? _c : undefined));\n    let branchPrefix = (_d = (await realmCard.value('branch')), (_d !== null && _d !== void 0 ? _d : ''));\n    let basePath = (_e = (await realmCard.value('basePath')), (_e !== null && _e !== void 0 ? _e : undefined));\n    let remote;\n    if (repo) {\n        repo = join(repoRootDir, repo);\n        await mkdirp(repo);\n    }\n    if (remoteUrl) {\n        if (!remoteCacheDir) {\n            throw new Error('You must provide a remoteCacheDir for remote repo config');\n        }\n        remote = {\n            url: remoteUrl,\n            cacheDir: join(repoRootDir, remoteCacheDir),\n        };\n        await mkdirp(remote.cacheDir);\n    }\n    if (repo && (remoteUrl || remoteCacheDir)) {\n        throw new Error('You cannot define the repo param with either the remoteUrl param or the remoteCacheDir param');\n    }\n    if (!repo && !remote) {\n        throw new Error('You must define a repo or a remoteUrl when configuring the git realm card');\n    }\n    return {\n        repo,\n        branchPrefix,\n        basePath,\n        remote,\n    };\n}\n//# sourceMappingURL=git-settings.js.map",
            "git-settings.js.map": "{\"version\":3,\"file\":\"git-settings.js\",\"sourceRoot\":\"\",\"sources\":[\"git-settings.ts\"],\"names\":[],\"mappings\":\"AAOA,OAAO,EAAE,OAAO,EAAE,MAAM,IAAI,CAAC;AAC7B,OAAO,EAAE,IAAI,EAAE,MAAM,MAAM,CAAC;AAC5B,OAAO,EAAE,MAAM,EAAE,MAAM,UAAU,CAAC;AAElC,OAAO,EAAE,KAAK,EAAE,MAAM,gBAAgB,CAAC;AAGvC,MAAM,CAAC,KAAK,UAAU,eAAe,CAAC,SAA0B;;IAC9D,6EAA6E;IAC7E,+EAA+E;IAC/E,MAAM,WAAW,GAAG,OAAO,CAAC,GAAG,CAAC,aAAa,IAAI,IAAI,CAAC,OAAO,EAAE,EAAE,YAAY,CAAC,CAAC;IAC/E,IAAI,IAAI,SAAG,CAAC,MAAM,SAAS,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,uCAAI,SAAS,EAAA,CAAC;IACxD,IAAI,SAAS,SAAG,CAAC,MAAM,SAAS,CAAC,KAAK,CAAC,WAAW,CAAC,CAAC,uCAAI,SAAS,EAAA,CAAC;IAClE,IAAI,cAAc,SAAG,CAAC,MAAM,SAAS,CAAC,KAAK,CAAC,gBAAgB,CAAC,CAAC,uCAAI,SAAS,EAAA,CAAC;IAC5E,IAAI,YAAY,SAAG,CAAC,MAAM,SAAS,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,uCAAI,EAAE,EAAA,CAAC;IAC3D,IAAI,QAAQ,SAAG,CAAC,MAAM,SAAS,CAAC,KAAK,CAAC,UAAU,CAAC,CAAC,uCAAI,SAAS,EAAA,CAAC;IAEhE,IAAI,MAAgC,CAAC;IAErC,IAAI,IAAI,EAAE;QACR,IAAI,GAAG,IAAI,CAAC,WAAW,EAAE,IAAI,CAAC,CAAC;QAC/B,MAAM,MAAM,CAAC,IAAI,CAAC,CAAC;KACpB;IAED,IAAI,SAAS,EAAE;QACb,IAAI,CAAC,cAAc,EAAE;YACnB,MAAM,IAAI,KAAK,CAAC,0DAA0D,CAAC,CAAC;SAC7E;QAED,MAAM,GAAG;YACP,GAAG,EAAE,SAAS;YACd,QAAQ,EAAE,IAAI,CAAC,WAAW,EAAE,cAAc,CAAC;SAC5C,CAAC;QACF,MAAM,MAAM,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;KAC/B;IACD,IAAI,IAAI,IAAI,CAAC,SAAS,IAAI,cAAc,CAAC,EAAE;QACzC,MAAM,IAAI,KAAK,CAAC,8FAA8F,CAAC,CAAC;KACjH;IAED,IAAI,CAAC,IAAI,IAAI,CAAC,MAAM,EAAE;QACpB,MAAM,IAAI,KAAK,CAAC,2EAA2E,CAAC,CAAC;KAC9F;IAED,OAAO;QACL,IAAI;QACJ,YAAY;QACZ,QAAQ;QACR,MAAM;KACP,CAAC;AACJ,CAAC\"}",
            "git-settings.ts": "interface IndexerSettings {\n  repo?: string;\n  basePath: string;\n  branchPrefix: string;\n  remote?: RemoteConfig;\n}\nimport { RemoteConfig } from './git';\nimport { homedir } from 'os';\nimport { join } from 'path';\nimport { mkdirp } from 'fs-extra';\n\nimport { Error } from '@cardstack/hub';\nimport { AddressableCard } from '@cardstack/hub';\n\nexport async function extractSettings(realmCard: AddressableCard): Promise<IndexerSettings> {\n  // In order to allow git realm cards to be portable, let's let the hub decide\n  // where the repo dir, as the root dir in one hub may not exist in another hub.\n  const repoRootDir = process.env.REPO_ROOT_DIR || join(homedir(), '.cardstack');\n  let repo = (await realmCard.value('repo')) ?? undefined;\n  let remoteUrl = (await realmCard.value('remoteUrl')) ?? undefined;\n  let remoteCacheDir = (await realmCard.value('remoteCacheDir')) ?? undefined;\n  let branchPrefix = (await realmCard.value('branch')) ?? '';\n  let basePath = (await realmCard.value('basePath')) ?? undefined;\n\n  let remote: RemoteConfig | undefined;\n\n  if (repo) {\n    repo = join(repoRootDir, repo);\n    await mkdirp(repo);\n  }\n\n  if (remoteUrl) {\n    if (!remoteCacheDir) {\n      throw new Error('You must provide a remoteCacheDir for remote repo config');\n    }\n\n    remote = {\n      url: remoteUrl,\n      cacheDir: join(repoRootDir, remoteCacheDir),\n    };\n    await mkdirp(remote.cacheDir);\n  }\n  if (repo && (remoteUrl || remoteCacheDir)) {\n    throw new Error('You cannot define the repo param with either the remoteUrl param or the remoteCacheDir param');\n  }\n\n  if (!repo && !remote) {\n    throw new Error('You must define a repo or a remoteUrl when configuring the git realm card');\n  }\n\n  return {\n    repo,\n    branchPrefix,\n    basePath,\n    remote,\n  };\n}\n",
            "git.d.ts": "/// <reference types=\"node\" />\nimport Tree from './tree';\ndeclare module 'isomorphic-git' {\n    interface ExplicitGitDir {\n        gitdir: string;\n    }\n    interface ImplicitGitDir {\n        dir: string;\n    }\n    type GitDir = ExplicitGitDir | ImplicitGitDir;\n    function findMergeBase(args: GitDir & {\n        core?: string;\n        fs?: any;\n        oids: string[];\n    }): Promise<string[]>;\n}\nimport { ReadCommitResult } from 'isomorphic-git';\nexport interface RemoteConfig {\n    url: string;\n    cacheDir: string;\n}\nimport { Moment } from 'moment-timezone';\nexport interface CommitOpts {\n    authorDate?: Moment;\n    authorEmail: string;\n    authorName: string;\n    message: string;\n    committerName?: string;\n    committerEmail?: string;\n}\ninterface PushOptions {\n    force?: boolean;\n}\nexport declare class Repository {\n    path: string;\n    private bare;\n    static open(path: string): Promise<Repository>;\n    static initBare(gitdir: string): Promise<Repository>;\n    static clone(url: string, dir: string): Promise<Repository>;\n    gitdir: string;\n    constructor(path: string, bare?: boolean);\n    getMasterCommit(): Promise<Commit>;\n    getRemote(remote: string): Promise<Remote>;\n    createBlobFromBuffer(buffer: Buffer): Promise<Oid>;\n    fetchAll(): Promise<void>;\n    mergeBranches(to: string, from: string): Promise<void>;\n    getReference(branchName: string): Promise<Reference>;\n    createBranch(targetBranch: string, headCommit: Commit): Promise<Reference>;\n    checkoutBranch(reference: Reference): Promise<void>;\n    getHeadCommit(): Promise<Commit>;\n    getReferenceCommit(name: string): Promise<Commit>;\n    lookupLocalBranch(branchName: string): Promise<Reference>;\n    lookupRemoteBranch(remote: string, branchName: string): Promise<Reference>;\n    lookupReference(reference: string): Promise<Reference>;\n    reset(commit: Commit, hard: boolean): Promise<void>;\n    isBare(): boolean;\n}\nexport declare class Commit {\n    private readonly repo;\n    private readonly commitInfo;\n    static create(repo: Repository, commitOpts: CommitOpts, tree: Tree, parents: Commit[]): Promise<Oid>;\n    static lookup(repo: Repository, id: Oid | string): Promise<Commit>;\n    constructor(repo: Repository, commitInfo: ReadCommitResult);\n    id(): Oid;\n    sha(): string;\n    getLog(): Promise<ReadCommitResult[]>;\n    getTree(): Promise<Tree>;\n}\nexport declare class Oid {\n    readonly sha: string;\n    constructor(sha: string);\n    toString(): string;\n    equal(other: Oid | string | undefined): boolean | \"\" | undefined;\n}\nexport declare class RepoNotFound extends Error {\n}\nexport declare class BranchNotFound extends Error {\n}\nexport declare class GitConflict extends Error {\n}\nexport declare class UnknownObjectId extends Error {\n}\ndeclare class Reference {\n    private readonly repo;\n    private readonly reference;\n    private readonly sha;\n    constructor(repo: Repository, reference: string, sha: string);\n    static lookup(repo: Repository, reference: string): Promise<Reference>;\n    target(): Oid;\n    setTarget(id: Oid): Promise<void>;\n    toString(): string;\n}\nexport declare class Remote {\n    private readonly repo;\n    private readonly remote;\n    static create(repo: Repository, remote: string, url: string): Promise<Remote>;\n    constructor(repo: Repository, remote: string);\n    push(ref: string, remoteRef: string, options?: PushOptions): Promise<void>;\n}\nexport declare class Merge {\n    static FASTFORWARD_ONLY: number;\n    static base(repo: Repository, one: Oid, two: Oid): Promise<Oid>;\n    static perform(repo: Repository, ourCommit: Commit, theirCommit: Commit, commitOpts: CommitOpts): Promise<import(\"isomorphic-git\").MergeResult>;\n}\nexport {};\n",
            "git.js": "import fs, { existsSync } from 'fs';\nimport http from 'isomorphic-git/http/node';\nimport { join } from 'path';\nimport Tree from './tree';\nconst { unlink } = fs.promises;\n// End temporary type wrangling\nimport { addRemote as igAddRemote, checkout as igCheckout, clone as igClone, commit as igCommit, currentBranch as igCurrentBranch, fetch as igFetch, findMergeBase as igFindMergeBase, init as igInit, listBranches as igListBranches, log as igLog, merge as igMerge, push as igPush, readCommit as igReadCommit, resolveRef as igResolveRef, writeBlob as igWriteBlob, writeRef as igWriteRef, } from 'isomorphic-git';\nimport moment from 'moment-timezone';\nexport class Repository {\n    constructor(path, bare = false) {\n        this.path = path;\n        this.bare = bare;\n        if (bare) {\n            this.gitdir = path;\n        }\n        else {\n            this.gitdir = join(path, '.git');\n        }\n    }\n    static async open(path) {\n        let bare = !existsSync(join(path, '.git'));\n        try {\n            let opts = bare ? { fs, gitdir: path } : { fs, dir: path };\n            // Try to get the current branch to check if it's really a git repo or not\n            await igCurrentBranch(opts);\n        }\n        catch (e) {\n            throw new RepoNotFound();\n        }\n        return new Repository(path, bare);\n    }\n    static async initBare(gitdir) {\n        await igInit({ gitdir, bare: true, fs });\n        return await Repository.open(gitdir);\n    }\n    static async clone(url, dir) {\n        await igClone({\n            fs,\n            http,\n            url,\n            dir,\n        });\n        return await Repository.open(dir);\n    }\n    async getMasterCommit() {\n        let sha = await igResolveRef({\n            fs,\n            gitdir: this.gitdir,\n            ref: 'master',\n        });\n        return await Commit.lookup(this, sha);\n    }\n    async getRemote(remote) {\n        return new Remote(this, remote);\n    }\n    async createBlobFromBuffer(buffer) {\n        let sha = await igWriteBlob({\n            fs,\n            gitdir: this.gitdir,\n            blob: buffer,\n        });\n        return new Oid(sha);\n    }\n    async fetchAll() {\n        await igFetch({\n            fs,\n            http,\n            gitdir: this.gitdir,\n        });\n    }\n    async mergeBranches(to, from) {\n        await igMerge({\n            fs,\n            gitdir: this.gitdir,\n            ours: to,\n            theirs: from,\n            fastForwardOnly: true,\n        });\n    }\n    async getReference(branchName) {\n        return await Reference.lookup(this, branchName);\n    }\n    async createBranch(targetBranch, headCommit) {\n        await igWriteRef({\n            fs,\n            gitdir: this.gitdir,\n            ref: `refs/heads/${targetBranch}`,\n            value: headCommit.sha(),\n            force: true,\n        });\n        return await Reference.lookup(this, targetBranch);\n    }\n    async checkoutBranch(reference) {\n        await igCheckout({\n            fs,\n            dir: this.path,\n            gitdir: this.gitdir,\n            ref: reference.toString(),\n        });\n    }\n    async getHeadCommit() {\n        return await Commit.lookup(this, 'HEAD');\n    }\n    async getReferenceCommit(name) {\n        return await Commit.lookup(this, name);\n    }\n    async lookupLocalBranch(branchName) {\n        let branches = await igListBranches({ fs, gitdir: this.gitdir });\n        if (branches.includes(branchName)) {\n            return await this.lookupReference(`refs/heads/${branchName}`);\n        }\n        else {\n            throw new BranchNotFound();\n        }\n    }\n    async lookupRemoteBranch(remote, branchName) {\n        let branches = await igListBranches({ fs, gitdir: this.gitdir, remote });\n        if (branches.includes(branchName)) {\n            return await this.lookupReference(`refs/remotes/${remote}/${branchName}`);\n        }\n        else {\n            throw new BranchNotFound();\n        }\n    }\n    async lookupReference(reference) {\n        return await Reference.lookup(this, reference);\n    }\n    async reset(commit, hard) {\n        let ref = await igCurrentBranch({\n            fs,\n            gitdir: this.gitdir,\n            fullname: true,\n        });\n        await igWriteRef({\n            fs,\n            gitdir: this.gitdir,\n            ref: ref,\n            value: commit.sha(),\n        });\n        if (hard) {\n            await unlink(join(this.gitdir, 'index'));\n            await igCheckout({ fs, dir: this.path, ref: ref });\n        }\n    }\n    isBare() {\n        return this.bare;\n    }\n}\nexport class Commit {\n    constructor(repo, commitInfo) {\n        this.repo = repo;\n        this.commitInfo = commitInfo;\n    }\n    static async create(repo, commitOpts, tree, parents) {\n        let sha = await igCommit(Object.assign(formatCommitOpts(commitOpts), {\n            fs,\n            gitdir: repo.gitdir,\n            tree: tree.id().toString(),\n            parent: parents.map(p => p.sha()),\n            noUpdateBranch: true,\n        }));\n        return new Oid(sha);\n    }\n    static async lookup(repo, id) {\n        try {\n            let commitInfo = await igReadCommit({\n                fs,\n                gitdir: repo.gitdir,\n                oid: id.toString(),\n            });\n            return new Commit(repo, commitInfo);\n        }\n        catch (e) {\n            if (e.code == 'NotFoundError') {\n                throw new UnknownObjectId();\n            }\n            else {\n                throw e;\n            }\n        }\n    }\n    id() {\n        return new Oid(this.commitInfo.oid);\n    }\n    sha() {\n        return this.commitInfo.oid;\n    }\n    async getLog() {\n        return await igLog({\n            fs,\n            gitdir: this.repo.gitdir,\n            ref: this.sha(),\n        });\n    }\n    async getTree() {\n        return await Tree.lookup(this.repo, new Oid(this.commitInfo.commit.tree));\n    }\n}\nexport class Oid {\n    constructor(sha) {\n        this.sha = sha;\n    }\n    toString() {\n        return this.sha;\n    }\n    equal(other) {\n        return other && other.toString() === this.toString();\n    }\n}\nexport class RepoNotFound extends Error {\n}\nexport class BranchNotFound extends Error {\n}\nexport class GitConflict extends Error {\n}\nexport class UnknownObjectId extends Error {\n}\nclass Reference {\n    constructor(repo, reference, sha) {\n        this.repo = repo;\n        this.reference = reference;\n        this.sha = sha;\n    }\n    static async lookup(repo, reference) {\n        let sha = await igResolveRef({\n            fs,\n            gitdir: repo.gitdir,\n            ref: reference,\n        });\n        return new Reference(repo, reference, sha);\n    }\n    target() {\n        return new Oid(this.sha);\n    }\n    async setTarget(id) {\n        await igWriteRef({\n            fs,\n            gitdir: this.repo.gitdir,\n            ref: this.reference,\n            value: id.toString(),\n            force: true,\n        });\n    }\n    toString() {\n        return this.reference;\n    }\n}\nexport class Remote {\n    constructor(repo, remote) {\n        this.repo = repo;\n        this.remote = remote;\n    }\n    static async create(repo, remote, url) {\n        await igAddRemote({\n            fs,\n            gitdir: await repo.gitdir,\n            remote,\n            url,\n        });\n        return new Remote(repo, remote);\n    }\n    async push(ref, remoteRef, options = {}) {\n        await igPush(Object.assign({\n            fs,\n            http,\n            gitdir: await this.repo.gitdir,\n            remote: this.remote,\n            ref,\n            remoteRef,\n        }, options));\n    }\n}\nfunction formatCommitOpts(commitOpts) {\n    let commitDate = moment(commitOpts.authorDate || new Date());\n    let author = {\n        name: commitOpts.authorName,\n        email: commitOpts.authorEmail,\n        timestamp: commitDate.unix(),\n        timezoneOffset: -commitDate.utcOffset(),\n    };\n    let committer;\n    if (commitOpts.committerName && commitOpts.committerEmail) {\n        committer = {\n            name: commitOpts.committerName,\n            email: commitOpts.committerEmail,\n        };\n    }\n    return {\n        author,\n        committer,\n        message: commitOpts.message,\n    };\n}\nexport class Merge {\n    static async base(repo, one, two) {\n        let oids = await igFindMergeBase({\n            fs,\n            gitdir: repo.gitdir,\n            oids: [one.toString(), two.toString()],\n        });\n        return new Oid(oids[0]);\n    }\n    static async perform(repo, ourCommit, theirCommit, commitOpts) {\n        try {\n            let res = await igMerge(Object.assign(formatCommitOpts(commitOpts), {\n                fs,\n                gitdir: repo.gitdir,\n                ours: ourCommit.sha(),\n                theirs: theirCommit.sha(),\n            }));\n            return res;\n        }\n        catch (e) {\n            if (e.code === 'MergeNotSupportedError') {\n                throw new GitConflict();\n            }\n            else {\n                throw e;\n            }\n        }\n    }\n}\nMerge.FASTFORWARD_ONLY = 2;\n//# sourceMappingURL=git.js.map",
            "git.js.map": "{\"version\":3,\"file\":\"git.js\",\"sourceRoot\":\"\",\"sources\":[\"git.ts\"],\"names\":[],\"mappings\":\"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\"}",
            "git.ts": "import fs, { existsSync } from 'fs';\nimport http from 'isomorphic-git/http/node';\nimport { join } from 'path';\n\nimport Tree from './tree';\n\nconst { unlink } = fs.promises;\n\n// Temporary type wrangling until https://github.com/isomorphic-git/isomorphic-git/pull/987 is merged and released\ndeclare module 'isomorphic-git' {\n  interface ExplicitGitDir {\n    gitdir: string;\n  }\n  interface ImplicitGitDir {\n    dir: string;\n  }\n  type GitDir = ExplicitGitDir | ImplicitGitDir;\n\n  export function findMergeBase(\n    args: GitDir & {\n      core?: string;\n      fs?: any;\n      oids: string[];\n    }\n  ): Promise<string[]>;\n}\n// End temporary type wrangling\n\nimport {\n  addRemote as igAddRemote,\n  checkout as igCheckout,\n  clone as igClone,\n  commit as igCommit,\n  currentBranch as igCurrentBranch,\n  fetch as igFetch,\n  findMergeBase as igFindMergeBase,\n  init as igInit,\n  listBranches as igListBranches,\n  log as igLog,\n  merge as igMerge,\n  push as igPush,\n  readCommit as igReadCommit,\n  resolveRef as igResolveRef,\n  writeBlob as igWriteBlob,\n  writeRef as igWriteRef,\n\n  // types\n  ReadCommitResult,\n} from 'isomorphic-git';\n\nexport interface RemoteConfig {\n  url: string;\n  cacheDir: string;\n}\n\nimport moment, { Moment } from 'moment-timezone';\n\nexport interface CommitOpts {\n  authorDate?: Moment;\n  authorEmail: string;\n  authorName: string;\n  message: string;\n  committerName?: string;\n  committerEmail?: string;\n}\n\ninterface PushOptions {\n  force?: boolean;\n}\n\nexport class Repository {\n  static async open(path: string) {\n    let bare = !existsSync(join(path, '.git'));\n\n    try {\n      let opts = bare ? { fs, gitdir: path } : { fs, dir: path };\n      // Try to get the current branch to check if it's really a git repo or not\n      await igCurrentBranch(opts);\n    } catch (e) {\n      throw new RepoNotFound();\n    }\n    return new Repository(path, bare);\n  }\n\n  static async initBare(gitdir: string): Promise<Repository> {\n    await igInit({ gitdir, bare: true, fs });\n    return await Repository.open(gitdir);\n  }\n\n  static async clone(url: string, dir: string) {\n    await igClone({\n      fs,\n      http,\n      url,\n      dir,\n    });\n    return await Repository.open(dir);\n  }\n\n  public gitdir: string;\n\n  constructor(public path: string, private bare: boolean = false) {\n    if (bare) {\n      this.gitdir = path;\n    } else {\n      this.gitdir = join(path, '.git');\n    }\n  }\n\n  async getMasterCommit(): Promise<Commit> {\n    let sha = await igResolveRef({\n      fs,\n      gitdir: this.gitdir,\n      ref: 'master',\n    });\n    return await Commit.lookup(this, sha);\n  }\n\n  async getRemote(remote: string): Promise<Remote> {\n    return new Remote(this, remote);\n  }\n\n  async createBlobFromBuffer(buffer: Buffer): Promise<Oid> {\n    let sha = await igWriteBlob({\n      fs,\n      gitdir: this.gitdir,\n      blob: buffer,\n    });\n\n    return new Oid(sha);\n  }\n\n  async fetchAll() {\n    await igFetch({\n      fs,\n      http,\n      gitdir: this.gitdir,\n    });\n  }\n\n  async mergeBranches(to: string, from: string) {\n    await igMerge({\n      fs,\n      gitdir: this.gitdir,\n      ours: to,\n      theirs: from,\n      fastForwardOnly: true,\n    });\n  }\n\n  async getReference(branchName: string) {\n    return await Reference.lookup(this, branchName);\n  }\n\n  async createBranch(targetBranch: string, headCommit: Commit): Promise<Reference> {\n    await igWriteRef({\n      fs,\n      gitdir: this.gitdir,\n      ref: `refs/heads/${targetBranch}`,\n      value: headCommit.sha(),\n      force: true,\n    });\n\n    return await Reference.lookup(this, targetBranch);\n  }\n\n  async checkoutBranch(reference: Reference) {\n    await igCheckout({\n      fs,\n      dir: this.path,\n      gitdir: this.gitdir,\n      ref: reference.toString(),\n    });\n  }\n\n  async getHeadCommit() {\n    return await Commit.lookup(this, 'HEAD');\n  }\n\n  async getReferenceCommit(name: string): Promise<Commit> {\n    return await Commit.lookup(this, name);\n  }\n\n  async lookupLocalBranch(branchName: string) {\n    let branches = await igListBranches({ fs, gitdir: this.gitdir });\n\n    if (branches.includes(branchName)) {\n      return await this.lookupReference(`refs/heads/${branchName}`);\n    } else {\n      throw new BranchNotFound();\n    }\n  }\n\n  async lookupRemoteBranch(remote: string, branchName: string) {\n    let branches = await igListBranches({ fs, gitdir: this.gitdir, remote });\n\n    if (branches.includes(branchName)) {\n      return await this.lookupReference(`refs/remotes/${remote}/${branchName}`);\n    } else {\n      throw new BranchNotFound();\n    }\n  }\n\n  async lookupReference(reference: string) {\n    return await Reference.lookup(this, reference);\n  }\n\n  async reset(commit: Commit, hard: boolean) {\n    let ref = await igCurrentBranch({\n      fs,\n      gitdir: this.gitdir,\n      fullname: true,\n    });\n\n    await igWriteRef({\n      fs,\n      gitdir: this.gitdir,\n      ref: ref as string,\n      value: commit.sha(),\n    });\n\n    if (hard) {\n      await unlink(join(this.gitdir, 'index'));\n      await igCheckout({ fs, dir: this.path, ref: ref as string });\n    }\n  }\n\n  isBare() {\n    return this.bare;\n  }\n}\n\nexport class Commit {\n  static async create(repo: Repository, commitOpts: CommitOpts, tree: Tree, parents: Commit[]): Promise<Oid> {\n    let sha = await igCommit(\n      Object.assign(formatCommitOpts(commitOpts), {\n        fs,\n        gitdir: repo.gitdir,\n        tree: tree.id()!.toString(),\n        parent: parents.map(p => p.sha()),\n        noUpdateBranch: true,\n      })\n    );\n    return new Oid(sha);\n  }\n\n  static async lookup(repo: Repository, id: Oid | string): Promise<Commit> {\n    try {\n      let commitInfo = await igReadCommit({\n        fs,\n        gitdir: repo.gitdir,\n        oid: id.toString(),\n      });\n      return new Commit(repo, commitInfo);\n    } catch (e) {\n      if (e.code == 'NotFoundError') {\n        throw new UnknownObjectId();\n      } else {\n        throw e;\n      }\n    }\n  }\n\n  constructor(private readonly repo: Repository, private readonly commitInfo: ReadCommitResult) {}\n\n  id() {\n    return new Oid(this.commitInfo.oid);\n  }\n\n  sha() {\n    return this.commitInfo.oid;\n  }\n\n  async getLog() {\n    return await igLog({\n      fs,\n      gitdir: this.repo.gitdir,\n      ref: this.sha(),\n    });\n  }\n\n  async getTree() {\n    return await Tree.lookup(this.repo, new Oid(this.commitInfo.commit.tree));\n  }\n}\n\nexport class Oid {\n  constructor(public readonly sha: string) {}\n\n  toString() {\n    return this.sha;\n  }\n\n  equal(other: Oid | string | undefined) {\n    return other && other.toString() === this.toString();\n  }\n}\nexport class RepoNotFound extends Error {}\nexport class BranchNotFound extends Error {}\nexport class GitConflict extends Error {}\nexport class UnknownObjectId extends Error {}\n\nclass Reference {\n  constructor(private readonly repo: Repository, private readonly reference: string, private readonly sha: string) {}\n\n  static async lookup(repo: Repository, reference: string) {\n    let sha = await igResolveRef({\n      fs,\n      gitdir: repo.gitdir,\n      ref: reference,\n    });\n\n    return new Reference(repo, reference, sha);\n  }\n\n  target() {\n    return new Oid(this.sha);\n  }\n\n  async setTarget(id: Oid): Promise<void> {\n    await igWriteRef({\n      fs,\n      gitdir: this.repo.gitdir,\n      ref: this.reference,\n      value: id.toString(),\n      force: true,\n    });\n  }\n\n  toString() {\n    return this.reference;\n  }\n}\n\nexport class Remote {\n  static async create(repo: Repository, remote: string, url: string): Promise<Remote> {\n    await igAddRemote({\n      fs,\n      gitdir: await repo.gitdir,\n      remote,\n      url,\n    });\n\n    return new Remote(repo, remote);\n  }\n\n  constructor(private readonly repo: Repository, private readonly remote: string) {}\n\n  async push(ref: string, remoteRef: string, options: PushOptions = {}): Promise<void> {\n    await igPush(\n      Object.assign(\n        {\n          fs,\n          http,\n          gitdir: await this.repo.gitdir,\n          remote: this.remote,\n          ref,\n          remoteRef,\n        },\n        options\n      )\n    );\n  }\n}\n\nfunction formatCommitOpts(commitOpts: CommitOpts) {\n  let commitDate = moment(commitOpts.authorDate || new Date());\n\n  let author = {\n    name: commitOpts.authorName,\n    email: commitOpts.authorEmail,\n    timestamp: commitDate.unix(),\n    timezoneOffset: -commitDate.utcOffset(),\n  };\n\n  let committer;\n\n  if (commitOpts.committerName && commitOpts.committerEmail) {\n    committer = {\n      name: commitOpts.committerName,\n      email: commitOpts.committerEmail,\n    };\n  }\n\n  return {\n    author,\n    committer,\n    message: commitOpts.message,\n  };\n}\n\nexport class Merge {\n  static FASTFORWARD_ONLY = 2;\n\n  static async base(repo: Repository, one: Oid, two: Oid): Promise<Oid> {\n    let oids = await igFindMergeBase({\n      fs,\n      gitdir: repo.gitdir,\n      oids: [one.toString(), two.toString()],\n    });\n    return new Oid(oids[0]);\n  }\n\n  static async perform(repo: Repository, ourCommit: Commit, theirCommit: Commit, commitOpts: CommitOpts) {\n    try {\n      let res = await igMerge(\n        Object.assign(formatCommitOpts(commitOpts), {\n          fs,\n          gitdir: repo.gitdir,\n          ours: ourCommit.sha(),\n          theirs: theirCommit.sha(),\n        })\n      );\n\n      return res;\n    } catch (e) {\n      if (e.code === 'MergeNotSupportedError') {\n        throw new GitConflict();\n      } else {\n        throw e;\n      }\n    }\n  }\n}\n",
            "service.d.ts": "import { Repository, RemoteConfig } from './git';\ndeclare class GitLocalCache {\n    private _remotes;\n    clearCache(): void;\n    getRepo(remoteUrl: string, remote: RemoteConfig): Promise<Repository>;\n    _makeRepo(remote: RemoteConfig): Promise<{\n        repo: Repository;\n        repoPath: string;\n    }>;\n    fetchAllFromRemote(remoteUrl: string): Promise<void>;\n    pullRepo(remoteUrl: string, targetBranch: string): Promise<void>;\n}\ndeclare const singleton: GitLocalCache;\nexport default singleton;\n",
            "service.js": "import { Repository } from './git';\nimport { promisify } from 'util';\nimport mkdirpcb from 'mkdirp';\nconst mkdirp = promisify(mkdirpcb);\nimport filenamifyUrl from 'filenamify-url';\nimport { existsSync } from 'fs';\nimport rimrafcb from 'rimraf';\nconst rimraf = promisify(rimrafcb);\nimport { join } from 'path';\nimport { tmpdir } from 'os';\nimport logger from '@cardstack/logger';\nconst log = logger('cardstack/git');\nclass GitLocalCache {\n    constructor() {\n        this._remotes = new Map();\n    }\n    clearCache() {\n        this._remotes = new Map();\n    }\n    async getRepo(remoteUrl, remote) {\n        let existingRepo = this._remotes.get(remoteUrl);\n        if (existingRepo) {\n            log.info('existing repo found for %s, reusing it from the cache', remoteUrl);\n            return existingRepo.repo;\n        }\n        let { repo, repoPath } = await this._makeRepo(remote);\n        this._remotes.set(remote.url, {\n            repo,\n            repoPath,\n        });\n        return repo;\n    }\n    async _makeRepo(remote) {\n        let cacheDirectory = remote.cacheDir;\n        if (!cacheDirectory) {\n            cacheDirectory = join(tmpdir(), 'cardstack-git-local-cache');\n            if (!existsSync(cacheDirectory)) {\n                await mkdirp(cacheDirectory);\n            }\n        }\n        let repoPath = join(cacheDirectory, filenamifyUrl(remote.url));\n        log.info('creating local repo cache for %s in %s', remote.url, repoPath);\n        let repo;\n        if (existsSync(repoPath)) {\n            try {\n                log.info('repo already exists - reusing local clone');\n                repo = await Repository.open(repoPath);\n            }\n            catch (e) {\n                log.info('creating repo from %s failed, deleting and recloning', repoPath);\n                // if opening existing repo fails for any reason we should just delete it and clone it\n                await rimraf(repoPath);\n                await mkdirp(repoPath);\n                repo = await Repository.clone(remote.url, repoPath);\n            }\n        }\n        else {\n            log.info('cloning %s into %s', remote.url, repoPath);\n            await mkdirp(repoPath);\n            repo = await Repository.clone(remote.url, repoPath);\n        }\n        return {\n            repo,\n            repoPath,\n        };\n    }\n    async fetchAllFromRemote(remoteUrl) {\n        let { repo } = this._remotes.get(remoteUrl);\n        return await repo.fetchAll();\n    }\n    async pullRepo(remoteUrl, targetBranch) {\n        log.info('pulling changes for branch %s on %s', targetBranch, remoteUrl);\n        let { repo } = this._remotes.get(remoteUrl);\n        // if branch does not exist locally then create it and reset to head of remote\n        // this is required because node git doesn't support direct pull https://github.com/nodegit/nodegit/issues/1123\n        try {\n            await repo.getReference(`${targetBranch}`);\n            log.info('reference for %s on %s already exists, continuing', targetBranch, remoteUrl);\n        }\n        catch (e) {\n            if (e.message.startsWith('no reference found for shorthand')) {\n                log.info('no local branch for %s on %s. Creating it now...', targetBranch, remoteUrl);\n                let headCommit = await repo.getHeadCommit();\n                let ref = await repo.createBranch(targetBranch, headCommit);\n                await repo.checkoutBranch(ref);\n                let remoteCommit = await repo.getReferenceCommit(`refs/remotes/origin/${targetBranch}`);\n                await repo.reset(remoteCommit, true);\n            }\n            else {\n                throw e;\n            }\n        }\n        await repo.fetchAll();\n        await repo.mergeBranches(targetBranch, `remotes/origin/${targetBranch}`);\n    }\n}\nconst singleton = new GitLocalCache();\nexport default singleton;\nmodule.exports = singleton;\n//# sourceMappingURL=service.js.map",
            "service.js.map": "{\"version\":3,\"file\":\"service.js\",\"sourceRoot\":\"\",\"sources\":[\"service.ts\"],\"names\":[],\"mappings\":\"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\"}",
            "service.ts": "import { Repository, RemoteConfig } from './git';\n\nimport { promisify } from 'util';\nimport mkdirpcb from 'mkdirp';\nconst mkdirp = promisify(mkdirpcb);\n\nimport filenamifyUrl from 'filenamify-url';\nimport { existsSync } from 'fs';\nimport rimrafcb from 'rimraf';\nconst rimraf = promisify(rimrafcb);\nimport { join } from 'path';\nimport { tmpdir } from 'os';\nimport logger from '@cardstack/logger';\nconst log = logger('cardstack/git');\n\ninterface RemoteCache {\n  repo: Repository;\n  repoPath: string;\n}\n\nclass GitLocalCache {\n  private _remotes: Map<string, RemoteCache> = new Map();\n\n  clearCache() {\n    this._remotes = new Map();\n  }\n\n  async getRepo(remoteUrl: string, remote: RemoteConfig) {\n    let existingRepo = this._remotes.get(remoteUrl);\n\n    if (existingRepo) {\n      log.info('existing repo found for %s, reusing it from the cache', remoteUrl);\n      return existingRepo.repo;\n    }\n\n    let { repo, repoPath } = await this._makeRepo(remote);\n\n    this._remotes.set(remote.url, {\n      repo,\n      repoPath,\n    });\n\n    return repo;\n  }\n\n  async _makeRepo(remote: RemoteConfig) {\n    let cacheDirectory = remote.cacheDir;\n\n    if (!cacheDirectory) {\n      cacheDirectory = join(tmpdir(), 'cardstack-git-local-cache');\n\n      if (!existsSync(cacheDirectory)) {\n        await mkdirp(cacheDirectory);\n      }\n    }\n\n    let repoPath = join(cacheDirectory, filenamifyUrl(remote.url));\n\n    log.info('creating local repo cache for %s in %s', remote.url, repoPath);\n\n    let repo;\n\n    if (existsSync(repoPath)) {\n      try {\n        log.info('repo already exists - reusing local clone');\n        repo = await Repository.open(repoPath);\n      } catch (e) {\n        log.info('creating repo from %s failed, deleting and recloning', repoPath);\n        // if opening existing repo fails for any reason we should just delete it and clone it\n        await rimraf(repoPath);\n\n        await mkdirp(repoPath);\n\n        repo = await Repository.clone(remote.url, repoPath);\n      }\n    } else {\n      log.info('cloning %s into %s', remote.url, repoPath);\n      await mkdirp(repoPath);\n\n      repo = await Repository.clone(remote.url, repoPath);\n    }\n\n    return {\n      repo,\n      repoPath,\n    };\n  }\n\n  async fetchAllFromRemote(remoteUrl: string) {\n    let { repo } = this._remotes.get(remoteUrl)!;\n    return await repo.fetchAll();\n  }\n\n  async pullRepo(remoteUrl: string, targetBranch: string) {\n    log.info('pulling changes for branch %s on %s', targetBranch, remoteUrl);\n    let { repo } = this._remotes.get(remoteUrl)!;\n\n    // if branch does not exist locally then create it and reset to head of remote\n    // this is required because node git doesn't support direct pull https://github.com/nodegit/nodegit/issues/1123\n    try {\n      await repo.getReference(`${targetBranch}`);\n      log.info('reference for %s on %s already exists, continuing', targetBranch, remoteUrl);\n    } catch (e) {\n      if (e.message.startsWith('no reference found for shorthand')) {\n        log.info('no local branch for %s on %s. Creating it now...', targetBranch, remoteUrl);\n        let headCommit = await repo.getHeadCommit();\n        let ref = await repo.createBranch(targetBranch, headCommit);\n        await repo.checkoutBranch(ref);\n        let remoteCommit = await repo.getReferenceCommit(`refs/remotes/origin/${targetBranch}`);\n        await repo.reset(remoteCommit, true);\n      } else {\n        throw e;\n      }\n    }\n\n    await repo.fetchAll();\n    await repo.mergeBranches(targetBranch, `remotes/origin/${targetBranch}`);\n  }\n}\n\nconst singleton = new GitLocalCache();\nexport default singleton;\nmodule.exports = singleton;\n",
            "todo-any.d.ts": "export declare type todo = any;\n",
            "todo-any.js": "//# sourceMappingURL=todo-any.js.map",
            "todo-any.js.map": "{\"version\":3,\"file\":\"todo-any.js\",\"sourceRoot\":\"\",\"sources\":[\"todo-any.ts\"],\"names\":[],\"mappings\":\"\"}",
            "todo-any.ts": "export type todo = any;\n",
            "tree.d.ts": "/// <reference types=\"node\" />\nimport { Repository, Oid } from './git';\nimport { ReadTreeResult, TreeEntry as igTreeEntry } from 'isomorphic-git';\nexport declare const enum FILEMODE {\n    TREE = \"040000\",\n    BLOB = \"100644\",\n    EXECUTABLE = \"100755\",\n    LINK = \"120000\",\n    COMMIT = \"160000\"\n}\nexport default class Tree {\n    private readonly repo;\n    private readonly containingEntry?;\n    static lookup(repo: Repository, oid: Oid, containingEntry?: TreeEntry): Promise<Tree>;\n    static create(repo: Repository, containingEntry?: TreeEntry): Tree;\n    private _entries;\n    private oid?;\n    dirty: boolean;\n    constructor(repo: Repository, containingEntry?: TreeEntry | undefined, readResult?: ReadTreeResult);\n    id(): Oid | undefined;\n    entries(): TreeEntry[];\n    entryByName(name: string): TreeEntry | undefined;\n    insert(name: string, contents: Tree | Buffer, filemode: FILEMODE): TreeEntry;\n    private removeEntryByName;\n    makeDirty(): void;\n    delete(name: string): Promise<void>;\n    fileAtPath(path: string, allowCreate: boolean): Promise<{\n        tree: Tree;\n        leaf: TreeEntry | undefined;\n        leafName: string;\n    }>;\n    traverse(path: string, allowCreate?: boolean): Promise<{\n        tree: Tree;\n        leaf: TreeEntry | undefined;\n        leafName: string;\n    }>;\n    path(): string;\n    write(allowEmpty?: boolean): Promise<Oid | undefined>;\n}\ninterface Blob {\n    id: Oid | null;\n    content(): Uint8Array;\n}\nexport declare class TreeEntry {\n    private readonly repo;\n    private readonly tree;\n    private readonly entry?;\n    private readonly _name?;\n    private contents?;\n    private readonly _filemode?;\n    private oid?;\n    static create(repo: Repository, tree: Tree, name: string, contents: Tree | Buffer, filemode: FILEMODE): TreeEntry;\n    static build(repo: Repository, tree: Tree, entry: igTreeEntry): TreeEntry;\n    private dirty;\n    constructor(repo: Repository, tree: Tree, entry?: igTreeEntry | undefined, _name?: string | undefined, contents?: Buffer | Tree | undefined, _filemode?: FILEMODE | undefined);\n    name(): string;\n    path(): string;\n    id(): Oid | null;\n    isTree(): boolean | undefined;\n    isBlob(): boolean | undefined;\n    filemode(): FILEMODE;\n    write(): Promise<void>;\n    getTree(): Promise<Tree>;\n    makeDirty(): void;\n    toTreeObject(): igTreeEntry;\n    removeFromParent(): void;\n    getBlob(): Promise<Blob>;\n}\nexport declare class FileNotFound extends Error {\n}\nexport declare class OverwriteRejected extends Error {\n}\nexport {};\n",
            "tree.js": "import { Oid } from './git';\nimport { readTree, readBlob, writeTree, writeBlob } from 'isomorphic-git';\nimport { join } from 'path';\nimport fs from 'fs';\nexport default class Tree {\n    constructor(repo, containingEntry, readResult) {\n        this.repo = repo;\n        this.containingEntry = containingEntry;\n        this.dirty = false;\n        if (readResult) {\n            this._entries = readResult.tree.map(e => TreeEntry.build(repo, this, e));\n            this.oid = new Oid(readResult.oid);\n        }\n        else {\n            this.dirty = true;\n            this._entries = [];\n        }\n    }\n    static async lookup(repo, oid, containingEntry) {\n        let readResult = await readTree({\n            fs,\n            gitdir: repo.gitdir,\n            oid: oid.sha,\n        });\n        return new Tree(repo, containingEntry, readResult);\n    }\n    static create(repo, containingEntry) {\n        return new Tree(repo, containingEntry);\n    }\n    id() {\n        return this.oid;\n    }\n    entries() {\n        return this._entries;\n    }\n    entryByName(name) {\n        return this._entries.find(e => e.name() === name);\n    }\n    insert(name, contents, filemode) {\n        this.removeEntryByName(name);\n        let entry = TreeEntry.create(this.repo, this, name, contents, filemode);\n        this._entries.push(entry);\n        this.makeDirty();\n        return entry;\n    }\n    removeEntryByName(name) {\n        this._entries = this._entries.filter(e => e.name() !== name);\n        this.makeDirty();\n    }\n    makeDirty() {\n        this.dirty = true;\n        if (this.containingEntry) {\n            this.containingEntry.makeDirty();\n        }\n    }\n    async delete(name) {\n        this.removeEntryByName(name);\n    }\n    async fileAtPath(path, allowCreate) {\n        let tombstone;\n        let { tree, leaf, leafName } = await this.traverse(path, allowCreate);\n        if (!leaf || leaf === tombstone || !leaf.isBlob()) {\n            leaf = undefined;\n        }\n        if (!leaf && !allowCreate) {\n            throw new FileNotFound(`No such file ${path}`);\n        }\n        return { tree, leaf, leafName };\n    }\n    async traverse(path, allowCreate = false) {\n        let parts = path.split('/');\n        let here = this;\n        while (parts.length > 1) {\n            let dirName = parts.shift();\n            let entry = here.entryByName(dirName);\n            if (!entry || !entry.isTree()) {\n                if (!allowCreate) {\n                    throw new FileNotFound(`${path} does not exist`);\n                }\n                entry = here.insert(dirName, Tree.create(here.repo, entry), \"040000\" /* TREE */);\n            }\n            here = await entry.getTree();\n        }\n        return {\n            tree: here,\n            leaf: here.entryByName(parts[0]),\n            leafName: parts[0],\n        };\n    }\n    path() {\n        if (this.containingEntry) {\n            return this.containingEntry.path();\n        }\n        else {\n            return '';\n        }\n    }\n    async write(allowEmpty = false) {\n        if (!this.dirty) {\n            return this.id();\n        }\n        for (let entry of this.entries()) {\n            await entry.write();\n        }\n        if (this.entries().length || allowEmpty) {\n            let sha = await writeTree({\n                fs,\n                gitdir: this.repo.gitdir,\n                tree: this.entries().map(e => e.toTreeObject()),\n            });\n            this.oid = new Oid(sha);\n            this.dirty = false;\n            return this.id();\n        }\n        else if (this.containingEntry) {\n            this.containingEntry.removeFromParent();\n        }\n    }\n}\nexport class TreeEntry {\n    constructor(repo, tree, entry, _name, contents, _filemode) {\n        this.repo = repo;\n        this.tree = tree;\n        this.entry = entry;\n        this._name = _name;\n        this.contents = contents;\n        this._filemode = _filemode;\n        if (this.entry) {\n            this.dirty = false;\n            this.oid = new Oid(this.entry.oid);\n        }\n        else {\n            this.dirty = true;\n        }\n    }\n    static create(repo, tree, name, contents, filemode) {\n        return new TreeEntry(repo, tree, undefined, name, contents, filemode);\n    }\n    static build(repo, tree, entry) {\n        return new TreeEntry(repo, tree, entry);\n    }\n    name() {\n        return this._name || this.entry.path;\n    }\n    path() {\n        return join(this.tree.path(), this.name());\n    }\n    id() {\n        return this.oid || null;\n    }\n    isTree() {\n        return this.contents instanceof Tree || (this.entry && this.entry.type == 'tree');\n    }\n    isBlob() {\n        return this.contents instanceof Buffer || (this.entry && this.entry.type == 'blob');\n    }\n    filemode() {\n        return this._filemode || this.entry.mode;\n    }\n    async write() {\n        if (this.isTree()) {\n            let tree = await this.getTree();\n            this.oid = await tree.write();\n            // this.tree.insert(this.name(), tree, FILEMODE.TREE);\n            this.dirty = false;\n            return;\n        }\n        if (!this.dirty) {\n            return;\n        }\n        let sha = await writeBlob({\n            fs,\n            gitdir: this.repo.gitdir,\n            blob: this.contents,\n        });\n        this.oid = new Oid(sha);\n        this.dirty = false;\n    }\n    async getTree() {\n        if (this.isTree() && this.contents) {\n            return this.contents;\n        }\n        let tree = await Tree.lookup(this.repo, this.id(), this);\n        this.contents = tree;\n        return tree;\n    }\n    makeDirty() {\n        this.dirty = true;\n        this.tree.makeDirty();\n    }\n    toTreeObject() {\n        return {\n            mode: this.filemode(),\n            path: this.name(),\n            type: this.isBlob() ? 'blob' : 'tree',\n            oid: this.oid.sha,\n        };\n    }\n    removeFromParent() {\n        this.tree.delete(this.name());\n    }\n    async getBlob() {\n        if (this.contents) {\n            let content = this.contents;\n            return {\n                id: null,\n                content() {\n                    return content;\n                },\n            };\n        }\n        let { blob: content } = await readBlob({\n            fs,\n            gitdir: this.repo.gitdir,\n            oid: this.entry.oid,\n        });\n        return {\n            id: this.id(),\n            content() {\n                return content;\n            },\n        };\n    }\n}\nexport class FileNotFound extends Error {\n}\nexport class OverwriteRejected extends Error {\n}\n//# sourceMappingURL=tree.js.map",
            "tree.js.map": "{\"version\":3,\"file\":\"tree.js\",\"sourceRoot\":\"\",\"sources\":[\"tree.ts\"],\"names\":[],\"mappings\":\"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\"}",
            "tree.ts": "import { Repository, Oid } from './git';\nimport { readTree, ReadTreeResult, TreeEntry as igTreeEntry, readBlob, writeTree, writeBlob } from 'isomorphic-git';\nimport { join } from 'path';\nimport fs from 'fs';\n\nexport const enum FILEMODE {\n  TREE = '040000',\n  BLOB = '100644',\n  EXECUTABLE = '100755',\n  LINK = '120000',\n  COMMIT = '160000',\n}\n\nexport default class Tree {\n  static async lookup(repo: Repository, oid: Oid, containingEntry?: TreeEntry) {\n    let readResult = await readTree({\n      fs,\n      gitdir: repo.gitdir,\n      oid: oid.sha,\n    });\n    return new Tree(repo, containingEntry, readResult);\n  }\n\n  static create(repo: Repository, containingEntry?: TreeEntry) {\n    return new Tree(repo, containingEntry);\n  }\n\n  private _entries: TreeEntry[];\n\n  private oid?: Oid;\n  public dirty = false;\n\n  constructor(\n    private readonly repo: Repository,\n    private readonly containingEntry?: TreeEntry,\n    readResult?: ReadTreeResult\n  ) {\n    if (readResult) {\n      this._entries = readResult.tree.map(e => TreeEntry.build(repo, this, e));\n      this.oid = new Oid(readResult.oid);\n    } else {\n      this.dirty = true;\n      this._entries = [];\n    }\n  }\n\n  id() {\n    return this.oid;\n  }\n\n  entries() {\n    return this._entries;\n  }\n\n  entryByName(name: string) {\n    return this._entries.find(e => e.name() === name);\n  }\n\n  insert(name: string, contents: Tree | Buffer, filemode: FILEMODE) {\n    this.removeEntryByName(name);\n    let entry = TreeEntry.create(this.repo, this, name, contents, filemode);\n    this._entries.push(entry);\n    this.makeDirty();\n    return entry;\n  }\n\n  private removeEntryByName(name: string) {\n    this._entries = this._entries.filter(e => e.name() !== name);\n    this.makeDirty();\n  }\n\n  makeDirty() {\n    this.dirty = true;\n    if (this.containingEntry) {\n      this.containingEntry.makeDirty();\n    }\n  }\n\n  async delete(name: string) {\n    this.removeEntryByName(name);\n  }\n\n  async fileAtPath(path: string, allowCreate: boolean) {\n    let tombstone;\n    let { tree, leaf, leafName } = await this.traverse(path, allowCreate);\n    if (!leaf || leaf === tombstone || !leaf.isBlob()) {\n      leaf = undefined;\n    }\n    if (!leaf && !allowCreate) {\n      throw new FileNotFound(`No such file ${path}`);\n    }\n    return { tree, leaf, leafName };\n  }\n\n  async traverse(path: string, allowCreate = false) {\n    let parts = path.split('/');\n    let here: Tree = this;\n\n    while (parts.length > 1) {\n      let dirName = parts.shift();\n      let entry: TreeEntry | undefined = here.entryByName(dirName!);\n      if (!entry || !entry.isTree()) {\n        if (!allowCreate) {\n          throw new FileNotFound(`${path} does not exist`);\n        }\n        entry = here.insert(dirName!, Tree.create(here.repo, entry), FILEMODE.TREE);\n      }\n      here = await entry!.getTree();\n    }\n\n    return {\n      tree: here,\n      leaf: here.entryByName(parts[0]),\n      leafName: parts[0],\n    };\n  }\n\n  path(): string {\n    if (this.containingEntry) {\n      return this.containingEntry.path();\n    } else {\n      return '';\n    }\n  }\n\n  async write(allowEmpty = false): Promise<Oid | undefined> {\n    if (!this.dirty) {\n      return this.id()!;\n    }\n    for (let entry of this.entries()) {\n      await entry.write();\n    }\n\n    if (this.entries().length || allowEmpty) {\n      let sha = await writeTree({\n        fs,\n        gitdir: this.repo.gitdir,\n        tree: this.entries().map(e => e.toTreeObject()),\n      });\n      this.oid = new Oid(sha);\n      this.dirty = false;\n      return this.id()!;\n    } else if (this.containingEntry) {\n      this.containingEntry.removeFromParent();\n    }\n  }\n}\n\ninterface Blob {\n  id: Oid | null;\n  content(): Uint8Array;\n}\n\nexport class TreeEntry {\n  private oid?: Oid;\n\n  static create(repo: Repository, tree: Tree, name: string, contents: Tree | Buffer, filemode: FILEMODE) {\n    return new TreeEntry(repo, tree, undefined, name, contents, filemode);\n  }\n\n  static build(repo: Repository, tree: Tree, entry: igTreeEntry) {\n    return new TreeEntry(repo, tree, entry);\n  }\n\n  private dirty: boolean;\n\n  constructor(\n    private readonly repo: Repository,\n    private readonly tree: Tree,\n    private readonly entry?: igTreeEntry,\n    private readonly _name?: string,\n    private contents?: Tree | Buffer,\n    private readonly _filemode?: FILEMODE\n  ) {\n    if (this.entry) {\n      this.dirty = false;\n      this.oid = new Oid(this.entry.oid);\n    } else {\n      this.dirty = true;\n    }\n  }\n\n  name() {\n    return this._name || this.entry!.path;\n  }\n\n  path() {\n    return join(this.tree.path(), this.name());\n  }\n\n  id() {\n    return this.oid || null;\n  }\n\n  isTree() {\n    return this.contents instanceof Tree || (this.entry && this.entry.type == 'tree');\n  }\n\n  isBlob() {\n    return this.contents instanceof Buffer || (this.entry && this.entry.type == 'blob');\n  }\n\n  filemode(): FILEMODE {\n    return this._filemode || (this.entry!.mode as FILEMODE);\n  }\n\n  async write() {\n    if (this.isTree()) {\n      let tree = await this.getTree();\n      this.oid = await tree.write();\n      // this.tree.insert(this.name(), tree, FILEMODE.TREE);\n      this.dirty = false;\n      return;\n    }\n\n    if (!this.dirty) {\n      return;\n    }\n\n    let sha = await writeBlob({\n      fs,\n      gitdir: this.repo.gitdir,\n      blob: this.contents as Buffer,\n    });\n\n    this.oid = new Oid(sha);\n\n    this.dirty = false;\n  }\n\n  async getTree() {\n    if (this.isTree() && this.contents) {\n      return this.contents as Tree;\n    }\n    let tree = await Tree.lookup(this.repo, this.id()!, this);\n    this.contents = tree;\n    return tree;\n  }\n\n  makeDirty() {\n    this.dirty = true;\n    this.tree.makeDirty();\n  }\n\n  toTreeObject(): igTreeEntry {\n    return {\n      mode: this.filemode(),\n      path: this.name(),\n      type: this.isBlob() ? 'blob' : 'tree',\n      oid: this.oid!.sha,\n    };\n  }\n\n  removeFromParent() {\n    this.tree.delete(this.name());\n  }\n\n  async getBlob(): Promise<Blob> {\n    if (this.contents) {\n      let content = this.contents as Buffer;\n      return {\n        id: null,\n        content() {\n          return content;\n        },\n      };\n    }\n    let { blob: content } = await readBlob({\n      fs,\n      gitdir: this.repo.gitdir,\n      oid: this.entry!.oid,\n    });\n\n    return {\n      id: this.id(),\n      content() {\n        return content;\n      },\n    };\n  }\n}\n\nexport class FileNotFound extends Error {}\nexport class OverwriteRejected extends Error {}\n"
          },
          "package.json": "{\n  \"name\": \"@cardstack/git-realm-card\",\n  \"version\": \"0.18.17\",\n  \"description\": \"Git data source plugin for @cardstack/hub.\",\n  \"repository\": \"https://github.com/cardstack/cardstack\",\n  \"license\": \"MIT\",\n  \"author\": \"Edward Faulkner <edward@eaf4.com>\",\n  \"publishConfig\": {\n    \"access\": \"public\"\n  },\n  \"dependencies\": {\n    \"@cardstack/logger\": \"^0.2.0\",\n    \"delay\": \"^4.1.0\",\n    \"filenamify-url\": \"^1.0.0\",\n    \"fs-extra\": \"^8.1.0\",\n    \"isomorphic-git\": \"^1.3.0\",\n    \"json-stable-stringify\": \"^1.0.1\",\n    \"jsonapi-typescript\": \"^0.1.3\",\n    \"lodash\": \"^4.17.11\",\n    \"mkdirp\": \"^0.5.1\",\n    \"moment-timezone\": \"^0.5.11\",\n    \"rimraf\": \"^2.6.2\",\n    \"tmp-promise\": \"2.0.2\",\n    \"truffle-contract\": \"^4.0.30\"\n  },\n  \"peerDependencies\": {\n    \"@cardstack/hub\": \"*\"\n  },\n  \"devDependencies\": {\n    \"@cardstack/eslint-config\": \"0.18.17\",\n    \"@cardstack/test-support\": \"0.18.17\",\n    \"sinon\": \"7.2.3\"\n  },\n  \"volta\": {\n    \"node\": \"12.13.1\",\n    \"yarn\": \"1.22.0\"\n  }\n}\n",
          "writer.d.ts": "import { Repository, RemoteConfig } from './lib/git';\nimport { todo } from './lib/todo-any';\nimport { Writer } from '@cardstack/hub';\nimport { Session } from '@cardstack/hub';\nimport { UpstreamDocument, UpstreamIdentity } from '@cardstack/hub';\nimport { AddressableCard } from '@cardstack/hub';\nexport default class GitWriter implements Writer {\n    private realmCard;\n    cards: import(\"@cardstack/hub/cards-service\").default;\n    myEmail: string;\n    myName: string;\n    remote?: RemoteConfig;\n    repoPath?: string;\n    basePath?: string;\n    repo?: Repository;\n    branchPrefix: string;\n    githereumConfig: todo;\n    githereum: todo;\n    _githereumPromise?: Promise<todo>;\n    constructor(realmCard: AddressableCard);\n    ready(): Promise<void>;\n    create(session: Session, document: UpstreamDocument, upstreamId: UpstreamIdentity | null): Promise<any>;\n    update(session: Session, id: UpstreamIdentity, document: UpstreamDocument): Promise<UpstreamDocument>;\n    delete(session: Session, id: UpstreamIdentity, version: string): Promise<any>;\n    _commitOptions(operation: string, id: string, session: Session): Promise<{\n        authorName: string;\n        authorEmail: string;\n        committerName: string;\n        committerEmail: string;\n        message: string;\n    }>;\n    private rootTree;\n    private cardTree;\n    private deleteCardTree;\n    private deleteTree;\n    private cardDirectoryFor;\n    private ensureRepo;\n    private generateId;\n}\n",
          "writer.js": "import { Repository, GitConflict, UnknownObjectId, Commit } from './lib/git';\nimport { FileNotFound, OverwriteRejected } from './lib/tree';\nimport crypto from 'crypto';\nimport Change from './lib/change';\nimport os from 'os';\nimport process from 'process';\nimport { Error } from '@cardstack/hub';\nimport { dir as mkTmpDir } from 'tmp-promise';\nimport { extractSettings } from './lib/git-settings';\nimport { inject } from '@cardstack/hub/dependency-injection';\nimport { writeCard } from '@cardstack/hub';\nimport { upstreamIdToCardDirName } from '@cardstack/hub';\nconst defaultBranch = 'master';\nexport default class GitWriter {\n    constructor(realmCard) {\n        this.realmCard = realmCard;\n        this.cards = inject('cards');\n        this.branchPrefix = '';\n        let hostname = os.hostname();\n        this.myName = `PID${process.pid} on ${hostname}`;\n        this.myEmail = `${os.userInfo().username}@${hostname}`;\n    }\n    async ready() {\n        let settings = await extractSettings(this.realmCard);\n        this.repoPath = settings.repo;\n        this.basePath = settings.basePath;\n        this.branchPrefix = settings.branchPrefix;\n        this.remote = settings.remote;\n    }\n    async create(session, document, upstreamId) {\n        let cardDirName;\n        if (!upstreamId) {\n            cardDirName = upstreamIdToCardDirName(await this.generateId());\n            if (!document.jsonapi.data.attributes) {\n                document.jsonapi.data.attributes = Object.create(null);\n            }\n            document.jsonapi.data.attributes.csId = cardDirName;\n        }\n        else {\n            cardDirName = upstreamIdToCardDirName(upstreamId);\n            if (!document.jsonapi.data.attributes) {\n                document.jsonapi.data.attributes = Object.create(null);\n            }\n            document.jsonapi.data.attributes.csId = typeof upstreamId === 'string' ? upstreamId : upstreamId.csId;\n            if (typeof upstreamId === 'object' && upstreamId.csOriginalRealm != null) {\n                document.jsonapi.data.attributes.csOriginalRealm = upstreamId.csOriginalRealm;\n            }\n        }\n        let cardDir = this.cardDirectoryFor(cardDirName);\n        return withErrorHandling(cardDir, async () => {\n            await this.ensureRepo();\n            let change = await Change.create(this.repo, null, this.branchPrefix + defaultBranch, !!this.remote);\n            await writeCard(cardDir, document.jsonapi, async (path, content) => {\n                let file = await change.get(path, { allowCreate: true });\n                file.setContent(content);\n            });\n            let signature = await this._commitOptions('create', cardDirName, session);\n            let version = await change.finalize(signature);\n            let meta;\n            meta = Object.assign({}, document.jsonapi.data.meta);\n            meta.version = version;\n            document.jsonapi.data.meta = meta;\n            return { saved: document, version, id: (upstreamId !== null && upstreamId !== void 0 ? upstreamId : cardDirName) };\n        });\n    }\n    async update(session, id, document) {\n        var _a;\n        let cardDirName = upstreamIdToCardDirName(id);\n        let meta = document.jsonapi.data.meta;\n        let version = (_a = meta) === null || _a === void 0 ? void 0 : _a.version;\n        if (version == null) {\n            throw new Error('missing required field \"meta.version\"', {\n                status: 400,\n                source: { pointer: '/data/meta/version' },\n            });\n        }\n        await this.ensureRepo();\n        let cardDir = this.cardDirectoryFor(cardDirName);\n        return withErrorHandling(cardDir, async () => {\n            let change = await Change.create(this.repo, version, this.branchPrefix + defaultBranch, !!this.remote);\n            await this.deleteCardTree(cardDir, change);\n            await writeCard(cardDir, document.jsonapi, async (path, content) => {\n                let file = await change.get(path, { allowCreate: true, allowUpdate: true });\n                file.setContent(content);\n            });\n            let signature = await this._commitOptions('update', cardDirName, session);\n            version = await change.finalize(signature);\n            meta = Object.assign({}, document.jsonapi.data.meta);\n            meta.version = version;\n            document.jsonapi.data.meta = meta;\n            return document;\n        });\n    }\n    async delete(session, id, version) {\n        let cardDirName = upstreamIdToCardDirName(id);\n        let cardDir = this.cardDirectoryFor(cardDirName);\n        if (!version) {\n            throw new Error('version is required', {\n                status: 400,\n                source: { pointer: '/data/meta/version' },\n            });\n        }\n        await this.ensureRepo();\n        return withErrorHandling(cardDir, async () => {\n            let change = await Change.create(this.repo, version, this.branchPrefix + defaultBranch, !!this.remote);\n            await this.deleteCardTree(cardDir, change);\n            let signature = await this._commitOptions('delete', cardDirName, session);\n            await change.finalize(signature);\n        });\n    }\n    async _commitOptions(operation, id, session) {\n        if (!session.unimplementedSession) {\n            throw new Error('Session not implemented');\n        }\n        // TODO use user session data when we add that capability\n        return {\n            authorName: 'Anonymous Coward',\n            authorEmail: 'anon@example.com',\n            committerName: this.myName,\n            committerEmail: this.myEmail,\n            message: `${operation} ${String(id).slice(12)}`,\n        };\n    }\n    async rootTree() {\n        await this.ensureRepo();\n        if (!this.repo) {\n            return;\n        }\n        let branchName = this.branchPrefix + defaultBranch;\n        let branch = await this.repo.lookupLocalBranch(branchName);\n        let headCommit = await Commit.lookup(this.repo, branch.target());\n        return await headCommit.getTree();\n    }\n    async cardTree(cardDir) {\n        let cardTree = await this.rootTree();\n        if (!cardTree) {\n            return;\n        }\n        let cardDirSegments = cardDir.split('/');\n        while (cardTree && cardDirSegments.length) {\n            let entry = cardTree.entryByName(cardDirSegments.shift());\n            if (!entry || !entry.isTree()) {\n                return;\n            }\n            cardTree = await entry.getTree();\n        }\n        return cardTree;\n    }\n    async deleteCardTree(cardDir, change) {\n        let cardTree = await this.cardTree(cardDir);\n        if (!cardTree) {\n            return;\n        }\n        await this.deleteTree(cardTree, change);\n    }\n    async deleteTree(tree, change) {\n        for (let entry of tree.entries()) {\n            if (entry.isTree()) {\n                await this.deleteTree(await entry.getTree(), change);\n            }\n            else {\n                let file = await change.get(entry.path());\n                file.delete();\n            }\n        }\n    }\n    cardDirectoryFor(cardDir) {\n        let base = this.basePath ? this.basePath + '/' : '';\n        let start;\n        if (base) {\n            start = `${base}/`;\n        }\n        else {\n            start = '';\n        }\n        return `${start}cards/${cardDir}`;\n    }\n    async ensureRepo() {\n        if (!this.repo) {\n            if (this.remote) {\n                let tempRepoPath = (await mkTmpDir()).path;\n                this.repo = await Repository.clone(this.remote.url, tempRepoPath);\n                return;\n            }\n            this.repo = await Repository.open(this.repoPath);\n        }\n    }\n    async generateId() {\n        let rootTree = await this.rootTree();\n        if (!rootTree) {\n            throw new Error(`Could not generate card ID because there is no repo for this git realm`);\n        }\n        while (true) {\n            let id = crypto.randomBytes(20).toString('hex');\n            let cardTree = await this.cardTree(this.cardDirectoryFor(id));\n            if (!cardTree) {\n                return id;\n            }\n        }\n    }\n}\nasync function withErrorHandling(cardDir, fn) {\n    try {\n        return await fn();\n    }\n    catch (err) {\n        if (err instanceof UnknownObjectId) {\n            throw new Error(err.message, { status: 400, source: { pointer: '/data/meta/version' } });\n        }\n        if (err instanceof GitConflict) {\n            throw new Error('Merge conflict', { status: 409 });\n        }\n        if (err instanceof OverwriteRejected) {\n            throw new Error(`The cardDir ${cardDir} is already in use`, {\n                status: 409,\n                source: { pointer: '/data/id' },\n            });\n        }\n        if (err instanceof FileNotFound) {\n            throw new Error(`The cardDir ${cardDir} does not exist`, {\n                status: 404,\n                source: { pointer: '/data/id' },\n            });\n        }\n        throw err;\n    }\n}\n//# sourceMappingURL=writer.js.map",
          "writer.js.map": "{\"version\":3,\"file\":\"writer.js\",\"sourceRoot\":\"\",\"sources\":[\"writer.ts\"],\"names\":[],\"mappings\":\"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\"}",
          "writer.ts": "import { Repository, RemoteConfig, GitConflict, UnknownObjectId, Commit } from './lib/git';\nimport Tree, { FileNotFound, OverwriteRejected, TreeEntry } from './lib/tree';\n\nimport { todo } from './lib/todo-any';\n\nimport crypto from 'crypto';\nimport Change from './lib/change';\nimport os from 'os';\nimport process from 'process';\nimport { Error } from '@cardstack/hub';\nimport { dir as mkTmpDir } from 'tmp-promise';\nimport { MetaObject } from 'jsonapi-typescript';\nimport { extractSettings } from './lib/git-settings';\n\nimport { Writer } from '@cardstack/hub';\nimport { Session } from '@cardstack/hub';\nimport { UpstreamDocument, UpstreamIdentity } from '@cardstack/hub';\nimport { inject } from '@cardstack/hub/dependency-injection';\nimport { AddressableCard } from '@cardstack/hub';\nimport { writeCard } from '@cardstack/hub';\nimport { upstreamIdToCardDirName } from '@cardstack/hub';\n\nconst defaultBranch = 'master';\n\nexport default class GitWriter implements Writer {\n  cards = inject('cards');\n\n  myEmail: string;\n  myName: string;\n  remote?: RemoteConfig;\n  repoPath?: string;\n  basePath?: string;\n  repo?: Repository;\n  branchPrefix = '';\n  githereumConfig: todo;\n  githereum: todo;\n  _githereumPromise?: Promise<todo>;\n\n  constructor(private realmCard: AddressableCard) {\n    let hostname = os.hostname();\n    this.myName = `PID${process.pid} on ${hostname}`;\n    this.myEmail = `${os.userInfo().username}@${hostname}`;\n  }\n\n  async ready(): Promise<void> {\n    let settings = await extractSettings(this.realmCard);\n    this.repoPath = settings.repo;\n    this.basePath = settings.basePath;\n    this.branchPrefix = settings.branchPrefix;\n    this.remote = settings.remote;\n  }\n\n  async create(session: Session, document: UpstreamDocument, upstreamId: UpstreamIdentity | null) {\n    let cardDirName: string;\n    if (!upstreamId) {\n      cardDirName = upstreamIdToCardDirName(await this.generateId());\n      if (!document.jsonapi.data.attributes) {\n        document.jsonapi.data.attributes = Object.create(null);\n      }\n      document.jsonapi.data.attributes!.csId = cardDirName;\n    } else {\n      cardDirName = upstreamIdToCardDirName(upstreamId);\n      if (!document.jsonapi.data.attributes) {\n        document.jsonapi.data.attributes = Object.create(null);\n      }\n      document.jsonapi.data.attributes!.csId = typeof upstreamId === 'string' ? upstreamId : upstreamId.csId;\n      if (typeof upstreamId === 'object' && upstreamId.csOriginalRealm != null) {\n        document.jsonapi.data.attributes!.csOriginalRealm = upstreamId.csOriginalRealm;\n      }\n    }\n\n    let cardDir = this.cardDirectoryFor(cardDirName);\n    return withErrorHandling(cardDir, async () => {\n      await this.ensureRepo();\n      let change = await Change.create(this.repo!, null, this.branchPrefix + defaultBranch, !!this.remote);\n\n      await writeCard(cardDir, document.jsonapi, async (path: string, content: string) => {\n        let file = await change.get(path, { allowCreate: true });\n        file.setContent(content);\n      });\n\n      let signature = await this._commitOptions('create', cardDirName, session);\n      let version = await change.finalize(signature);\n      let meta: MetaObject | undefined;\n\n      meta = Object.assign({}, document.jsonapi.data.meta);\n      meta.version = version;\n      document.jsonapi.data.meta = meta;\n\n      return { saved: document, version, id: upstreamId ?? cardDirName };\n    });\n  }\n\n  async update(session: Session, id: UpstreamIdentity, document: UpstreamDocument): Promise<UpstreamDocument> {\n    let cardDirName = upstreamIdToCardDirName(id);\n\n    let meta = document.jsonapi.data.meta;\n\n    let version = meta?.version;\n    if (version == null) {\n      throw new Error('missing required field \"meta.version\"', {\n        status: 400,\n        source: { pointer: '/data/meta/version' },\n      });\n    }\n    await this.ensureRepo();\n\n    let cardDir = this.cardDirectoryFor(cardDirName);\n    return withErrorHandling(cardDir, async () => {\n      let change = await Change.create(this.repo!, version as string, this.branchPrefix + defaultBranch, !!this.remote);\n\n      await this.deleteCardTree(cardDir, change);\n      await writeCard(cardDir, document.jsonapi, async (path: string, content: string) => {\n        let file = await change.get(path, { allowCreate: true, allowUpdate: true });\n        file.setContent(content);\n      });\n\n      let signature = await this._commitOptions('update', cardDirName, session);\n      version = await change.finalize(signature);\n\n      meta = Object.assign({}, document.jsonapi.data.meta);\n      meta.version = version;\n      document.jsonapi.data.meta = meta;\n\n      return document;\n    });\n  }\n\n  async delete(session: Session, id: UpstreamIdentity, version: string) {\n    let cardDirName = upstreamIdToCardDirName(id);\n    let cardDir = this.cardDirectoryFor(cardDirName);\n\n    if (!version) {\n      throw new Error('version is required', {\n        status: 400,\n        source: { pointer: '/data/meta/version' },\n      });\n    }\n\n    await this.ensureRepo();\n    return withErrorHandling(cardDir, async () => {\n      let change = await Change.create(this.repo!, version, this.branchPrefix + defaultBranch, !!this.remote);\n\n      await this.deleteCardTree(cardDir, change);\n      let signature = await this._commitOptions('delete', cardDirName, session);\n      await change.finalize(signature);\n    });\n  }\n\n  async _commitOptions(operation: string, id: string, session: Session) {\n    if (!session.unimplementedSession) {\n      throw new Error('Session not implemented');\n    }\n    // TODO use user session data when we add that capability\n    return {\n      authorName: 'Anonymous Coward',\n      authorEmail: 'anon@example.com',\n      committerName: this.myName,\n      committerEmail: this.myEmail,\n      message: `${operation} ${String(id).slice(12)}`,\n    };\n  }\n\n  private async rootTree(): Promise<Tree | undefined> {\n    await this.ensureRepo();\n    if (!this.repo) {\n      return;\n    }\n    let branchName = this.branchPrefix + defaultBranch;\n    let branch = await this.repo.lookupLocalBranch(branchName);\n    let headCommit = await Commit.lookup(this.repo, branch.target());\n    return await headCommit.getTree();\n  }\n\n  private async cardTree(cardDir: string): Promise<Tree | undefined> {\n    let cardTree = await this.rootTree();\n    if (!cardTree) {\n      return;\n    }\n\n    let cardDirSegments = cardDir.split('/');\n    while (cardTree && cardDirSegments.length) {\n      let entry: TreeEntry | undefined = cardTree.entryByName(cardDirSegments.shift()!);\n      if (!entry || !entry.isTree()) {\n        return;\n      }\n      cardTree = await entry.getTree();\n    }\n    return cardTree;\n  }\n\n  private async deleteCardTree(cardDir: string, change: Change): Promise<void> {\n    let cardTree = await this.cardTree(cardDir);\n    if (!cardTree) {\n      return;\n    }\n\n    await this.deleteTree(cardTree, change);\n  }\n\n  private async deleteTree(tree: Tree, change: Change) {\n    for (let entry of tree.entries()) {\n      if (entry.isTree()) {\n        await this.deleteTree(await entry.getTree(), change);\n      } else {\n        let file = await change.get(entry.path());\n        file.delete();\n      }\n    }\n  }\n\n  private cardDirectoryFor(cardDir: string) {\n    let base = this.basePath ? this.basePath + '/' : '';\n    let start: string;\n\n    if (base) {\n      start = `${base}/`;\n    } else {\n      start = '';\n    }\n    return `${start}cards/${cardDir}`;\n  }\n\n  private async ensureRepo() {\n    if (!this.repo) {\n      if (this.remote) {\n        let tempRepoPath = (await mkTmpDir()).path;\n        this.repo = await Repository.clone(this.remote.url, tempRepoPath);\n        return;\n      }\n\n      this.repo = await Repository.open(this.repoPath!);\n    }\n  }\n\n  private async generateId() {\n    let rootTree = await this.rootTree();\n    if (!rootTree) {\n      throw new Error(`Could not generate card ID because there is no repo for this git realm`);\n    }\n\n    while (true) {\n      let id = crypto.randomBytes(20).toString('hex');\n      let cardTree = await this.cardTree(this.cardDirectoryFor(id));\n      if (!cardTree) {\n        return id;\n      }\n    }\n  }\n}\n\nasync function withErrorHandling(cardDir: string | undefined, fn: Function) {\n  try {\n    return await fn();\n  } catch (err) {\n    if (err instanceof UnknownObjectId) {\n      throw new Error(err.message, { status: 400, source: { pointer: '/data/meta/version' } });\n    }\n    if (err instanceof GitConflict) {\n      throw new Error('Merge conflict', { status: 409 });\n    }\n    if (err instanceof OverwriteRejected) {\n      throw new Error(`The cardDir ${cardDir} is already in use`, {\n        status: 409,\n        source: { pointer: '/data/id' },\n      });\n    }\n    if (err instanceof FileNotFound) {\n      throw new Error(`The cardDir ${cardDir} does not exist`, {\n        status: 404,\n        source: { pointer: '/data/id' },\n      });\n    }\n    throw err;\n  }\n}\n"
        },
        "csId": "git-realm",
        "csPeerDependencies": {
          "@cardstack/hub": "*"
        },
        "csUpdated": "2020-11-17T21:16:22.266Z"
      },
      "id": "https://base.cardstack.com/public/cards/git-realm",
      "meta": {
        "cardDir": "/cardstack/node_modules/@cardstack/git-realm-card"
      },
      "relationships": {
        "csAdoptsFrom": {
          "data": {
            "id": "https://base.cardstack.com/public/cards/base",
            "type": "cards"
          }
        }
      },
      "type": "cards"
    },
    {
      "attributes": {
        "csCreated": "2020-11-17T21:16:22.279Z",
        "csDescription": "This represents cards of any type",
        "csFeatures": {
          "embedded-css": "embedded.css",
          "isolated-css": "isolated.css"
        },
        "csFiles": {
          "card.json": "{\n  \"data\": {\n    \"type\": \"cards\",\n    \"attributes\": {\n      \"csId\": \"base\",\n      \"csTitle\": \"Base Card\",\n      \"csDescription\": \"This represents cards of any type\",\n      \"csFeatures\": {\n        \"isolated-css\": \"isolated.css\",\n        \"embedded-css\": \"embedded.css\"\n      }\n    },\n    \"relationships\": {\n    }\n  }\n}",
          "embedded.css": "/* This is the embedded base card template. All cards will inherit this CSS if\nno custom CSS is provided for the card.*/\n\n.card-boundary {\n  width: 100%;\n  max-width: 450px;\n  min-height: 90px;\n  margin: 0;\n  border-radius: 10px;\n  background-color: white;\n  color: black;\n  font: 400 10px/1.2 'Open Sans';\n  letter-spacing: 0.03em;\n  text-align: left;\n  overflow: hidden;\n  overflow-wrap: break-word;\n  word-break: break-word;\n}\n\n.embedded-card--view-fields {\n  display: grid; /* Helpful for ordering fields */\n}\n.embedded-card--view-fields::before,\n.embedded-card--view-fields::after {\n  height: 0; /* for firefox */\n}\n\n.field {\n  display: grid;\n  grid-template-columns: 1fr 1.5fr;\n  grid-gap: 0 10px;\n  width: 100%;\n  margin: 0 auto;\n  padding: 0 15px 15px;\n}\n.field.field-type-belongs-to-view-field,\n.field:first-of-type {\n  padding-top: 15px;\n}\n\n.label {\n  padding-bottom: 4px;\n  color: var(--black);\n  font-size: 7px;\n  font-weight: bold;\n  letter-spacing: 0.1em;\n  line-height: 1.364;\n  text-transform: uppercase;\n}\n\n\n/**** SPECIAL FIELD TYPES ****/\n\n/* field-type: link */\n/* use `label` for link text and `value` for link url */\n.link-viewer {\n  color: var(--cobalt-blue);\n  text-decoration: underline;\n  font-weight: 600;\n}\n\n/* field-type: cta */\n/* use `label` for button text and `value` for button link url */\n.cta-viewer {\n  min-height: 1em;\n  border-radius: 6px;\n  font-size: 10px;\n  font-weight: 700;\n  line-height: calc(22 / 15);\n  letter-spacing: 0.03em;\n  padding: 6px;\n}\n\n/* field-type: decorative-image */\n.decorative-image-viewer {\n  max-height: 50px;\n}\n\n\n/**** SPECIAL FIELD IDs ****/\n\n/* field-id: background-image */\n.background-image-field {\n  display: block;\n  max-width: 100%;\n  padding: 0;\n  order: -100; /* first item on page */\n}\n.background-image-field > .label {\n  display: none;\n}\n.background-image-field > .value {\n  width: 100%;\n  max-height: 75px;\n  object-fit: cover;\n  object-position: center;\n}\n\n/* field-id: title */\n.title-field {\n  display: block;\n  padding-bottom: 7px;\n}\n.title-field > .label {\n  display: none;\n}\n.title-field > .value {\n  color: var(--dark-gray);\n  font-size: 14px;\n  font-weight: bold;\n  letter-spacing: 0.015em;\n  line-height: 1.2;\n}\n\n/* field-id: highlight-title */\n.highlight-title-field {\n  display: block;\n}\n.highlight-title-field > .label {\n  display: none;\n}\n.highlight-title-field > .value {\n  color: var(--red);\n  font-size: 10px;\n  font-weight: bold;\n  letter-spacing: 0.035em;\n  text-transform: capitalize;\n}\n\n/* field-id: divider */\n.divider-field {\n  display: block;\n  width: calc(100% - 30px);\n  border-top: 1px solid var(--light-gray);\n}\n.divider-field > .label,\n.divider-field > .value {\n  display: none;\n}\n\n/* field-id: description */\n.description-field {\n  display: block;\n}\n",
          "isolated.css": "/* This is the isolated base card template. All cards will inherit this CSS if\nno custom CSS is provided for the card.*/\n\n.isolated-card {\n  margin: 0 auto;\n  background-color: #fff;\n  color: #000;\n  font-family: 'Open Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif;\n  font-size: 16px;\n  line-height: calc(22/16);\n  letter-spacing: 0.015em;\n}\n\n.isolated-card--view-fields {\n  display: grid;\n  gap: 10px;\n  padding: 30px;\n}\n\n.field {\n  display: grid;\n  grid-template-columns: 2fr 4.5fr;\n  gap: 30px;\n  max-width: 700px;\n  width: 100%;\n  margin: 0 auto;\n  padding: 10px;\n}\n\n.label {\n  font-size: 13px;\n  font-weight: 700;\n  letter-spacing: 0.05em;\n  line-height: calc(22/13);\n  text-transform: uppercase;\n  text-align: right;\n  text-overflow: ellipsis;\n  overflow: hidden;\n}\n\n.value {\n  max-width: 100%;\n  text-overflow: ellipsis;\n  overflow: hidden;\n}\n",
          "package.json": "{\n  \"name\": \"@cardstack/base-card\",\n  \"version\": \"0.18.17\",\n  \"license\": \"MIT\",\n  \"publishConfig\": {\n    \"access\": \"public\"\n  },\n  \"peerDependencies\": {\n    \"@cardstack/hub\": \"*\"\n  },\n  \"devDependencies\": {\n    \"@cardstack/hub\": \"0.18.17\"\n  },\n  \"volta\": {\n    \"node\": \"12.13.1\",\n    \"yarn\": \"1.22.0\"\n  }\n}\n"
        },
        "csId": "base",
        "csPeerDependencies": {
          "@cardstack/hub": "*"
        },
        "csTitle": "Base Card",
        "csUpdated": "2020-11-17T21:16:22.279Z"
      },
      "id": "https://base.cardstack.com/public/cards/base",
      "meta": {
        "cardDir": "/cardstack/node_modules/@cardstack/base-card"
      },
      "relationships": {
      },
      "type": "cards"
    }
  ]
}
{
  "data": {
    "attributes": {
      "csCreated": "2020-11-17T21:16:30.151Z",
      "csDescription": "This card controls the configuration of the base realm which contains all the built-in cards.",
      "csFields": {
      },
      "csId": "https://base.cardstack.com/public",
      "csTitle": "Base Realm",
      "csUpdated": "2020-11-17T21:16:30.151Z",
      "directory": "/cardstack/cards"
    },
    "id": "http://localhost:3000/api/realms/meta/cards/https%3A%2F%2Fbase.cardstack.com%2Fpublic",
    "relationships": {
      "csAdoptsFrom": {
        "data": {
          "id": "https://base.cardstack.com/public/cards/files-realm",
          "type": "cards"
        }
      }
    },
    "type": "cards"
  },
  "included": [
    {
      "attributes": {
        "csCreated": "2020-11-17T21:16:30.160Z",
        "csFeatures": {
          "indexer": "indexer.js",
          "writer": "writer.js"
        },
        "csFields": {
          "directory": {
            "relationships": {
              "csAdoptsFrom": {
                "data": {
                  "id": "https://base.cardstack.com/public/cards/string-field",
                  "type": "cards"
                }
              }
            }
          },
          "watcherEnabled": {
            "relationships": {
              "csAdoptsFrom": {
                "data": {
                  "id": "https://base.cardstack.com/public/cards/boolean-field",
                  "type": "cards"
                }
              }
            }
          }
        },
        "csFiles": {
          "card.json": "{\n  \"data\": {\n    \"type\": \"cards\",\n    \"attributes\": {\n      \"csId\": \"files-realm\",\n      \"csFeatures\": {\n        \"indexer\": \"indexer.js\",\n        \"writer\": \"writer.js\"\n      },\n      \"csFields\": {\n        \"directory\": {\n          \"relationships\": {\n            \"csAdoptsFrom\": {\n              \"data\": {\n                \"type\": \"cards\",\n                \"id\": \"https://base.cardstack.com/public/cards/string-field\"\n              }\n            }\n          }\n        },\n        \"watcherEnabled\": {\n          \"relationships\": {\n            \"csAdoptsFrom\": {\n              \"data\": {\n                \"type\": \"cards\",\n                \"id\": \"https://base.cardstack.com/public/cards/boolean-field\"\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n",
          "indexer.d.ts": "import { Indexer, IndexingOperations } from '@cardstack/hub';\nimport { AddressableCard } from '@cardstack/hub';\nimport { TrackerParams } from './tracker';\nexport default class FilesIndexer implements Indexer<unknown, TrackerParams> {\n    private realmCard;\n    filesTracker: import(\"./tracker\").FilesTracker;\n    constructor(realmCard: AddressableCard);\n    update(_meta: unknown, ops: IndexingOperations, params: TrackerParams | null): Promise<void>;\n}\n",
          "indexer.js": "import { inject } from '@cardstack/hub/dependency-injection';\nexport default class FilesIndexer {\n    constructor(realmCard) {\n        this.realmCard = realmCard;\n        this.filesTracker = inject('filesTracker');\n    }\n    // we delegate to the FilesTracker because it has a lifetime that lasts as\n    // long as the DI container, whereas this indexer can be short-lived.\n    async update(_meta, ops, params) {\n        return await this.filesTracker.update(this.realmCard, ops, params);\n    }\n}\n//# sourceMappingURL=indexer.js.map",
          "indexer.js.map": "{\"version\":3,\"file\":\"indexer.js\",\"sourceRoot\":\"\",\"sources\":[\"indexer.ts\"],\"names\":[],\"mappings\":\"AAEA,OAAO,EAAE,MAAM,EAAE,MAAM,qCAAqC,CAAC;AAG7D,MAAM,CAAC,OAAO,OAAO,YAAY;IAG/B,YAAoB,SAA0B;QAA1B,cAAS,GAAT,SAAS,CAAiB;QAF9C,iBAAY,GAAG,MAAM,CAAC,cAAc,CAAC,CAAC;IAEW,CAAC;IAElD,0EAA0E;IAC1E,qEAAqE;IACrE,KAAK,CAAC,MAAM,CAAC,KAAc,EAAE,GAAuB,EAAE,MAA4B;QAChF,OAAO,MAAM,IAAI,CAAC,YAAY,CAAC,MAAM,CAAC,IAAI,CAAC,SAAS,EAAE,GAAG,EAAE,MAAM,CAAC,CAAC;IACrE,CAAC;CACF\"}",
          "indexer.ts": "import { Indexer, IndexingOperations } from '@cardstack/hub';\nimport { AddressableCard } from '@cardstack/hub';\nimport { inject } from '@cardstack/hub/dependency-injection';\nimport { TrackerParams } from './tracker';\n\nexport default class FilesIndexer implements Indexer<unknown, TrackerParams> {\n  filesTracker = inject('filesTracker');\n\n  constructor(private realmCard: AddressableCard) {}\n\n  // we delegate to the FilesTracker because it has a lifetime that lasts as\n  // long as the DI container, whereas this indexer can be short-lived.\n  async update(_meta: unknown, ops: IndexingOperations, params: TrackerParams | null) {\n    return await this.filesTracker.update(this.realmCard, ops, params);\n  }\n}\n",
          "package.json": "{\n  \"name\": \"@cardstack/files-realm-card\",\n  \"version\": \"0.18.17\",\n  \"main\": \"index.js\",\n  \"license\": \"MIT\",\n  \"publishConfig\": {\n    \"access\": \"public\"\n  },\n  \"peerDependencies\": {\n    \"@cardstack/hub\": \"*\"\n  },\n  \"devDependencies\": {\n    \"@cardstack/hub\": \"0.18.17\"\n  },\n  \"dependencies\": {\n    \"@cardstack/logger\": \"^0.2.1\",\n    \"@types/sane\": \"^2.0.0\",\n    \"fs-extra\": \"^8.1.0\",\n    \"json-typescript\": \"^1.1.2\",\n    \"jsonapi-typescript\": \"^0.1.3\",\n    \"lodash\": \"^4.17.15\",\n    \"sane\": \"^4.1.0\"\n  },\n  \"volta\": {\n    \"node\": \"12.13.1\",\n    \"yarn\": \"1.22.0\"\n  }\n}\n",
          "tracker.d.ts": "import { IndexingOperations } from '@cardstack/hub';\nimport { AddressableCard } from '@cardstack/hub';\nexport interface TrackerParams {\n    fileChanged?: string;\n}\nexport declare class FilesTracker {\n    indexing: import(\"@cardstack/hub/indexing\").default;\n    private state;\n    private ids;\n    private subscriptions;\n    update(realmCard: AddressableCard, ops: IndexingOperations, params: TrackerParams | null): Promise<void>;\n    private reindexCard;\n    private targetedUpdate;\n    private subscribe;\n    notifyFileDidChange(realmDir: string, relativeFile: string): void;\n    notifyFileDidChangeAndWait(realmDir: string, relativeFile: string): Promise<void>;\n    willTeardown(): Promise<void>;\n}\ndeclare module '@cardstack/hub/dependency-injection' {\n    interface KnownServices {\n        filesTracker: FilesTracker;\n    }\n}\n",
          "tracker.js": "import { statSync, readdirSync, readJsonSync, readFileSync } from 'fs-extra';\nimport { join } from 'path';\nimport merge from 'lodash/merge';\nimport logger from '@cardstack/logger';\nimport { UpstreamDocument } from '@cardstack/hub';\nimport { assertSingleResourceDoc } from '@cardstack/hub';\nimport { inject } from '@cardstack/hub/dependency-injection';\nimport sane from 'sane';\nconst log = logger('files-realm-tracker');\n// This holds the persistent state for the files-realm while the hub is running.\n// It deals with file watching and noticing incremental changes.\nexport class FilesTracker {\n    constructor() {\n        this.indexing = inject('indexing');\n        this.state = new Map();\n        this.ids = new Map();\n        this.subscriptions = new Map();\n    }\n    async update(realmCard, ops, params) {\n        var _a;\n        let directory = await realmCard.value('directory');\n        if ((_a = params) === null || _a === void 0 ? void 0 : _a.fileChanged) {\n            await this.targetedUpdate(ops, directory, params.fileChanged);\n            return;\n        }\n        await this.subscribe(directory, realmCard);\n        let now = crawl(directory);\n        let previous = this.state.get(directory);\n        if (!previous) {\n            await ops.beginReplaceAll();\n        }\n        for (let [name, entry] of now) {\n            if (entry instanceof Map) {\n                // we found a directory within the top-level cards directory, so it's\n                // supposed to be card.\n                if (previous && !changed(previous.get(name), entry)) {\n                    continue;\n                }\n                let cardDir = join(directory, name);\n                await this.reindexCard(cardDir, entry, directory, ops);\n            }\n            else {\n                // we found a file in within the top-level cards directory, we ignore\n                // those.\n            }\n        }\n        if (previous) {\n            for (let [name, previousEntry] of previous) {\n                if (!(previousEntry instanceof Map)) {\n                    // it was a file before, so there's no chance we need to delete a card\n                    continue;\n                }\n                // it was a directory before, so we're responsible for checking that\n                // it's still a card.\n                let currentEntry = now.get(name);\n                // if the directory has been deleted or replaced with a file, we need to\n                // remove from search index\n                if (!currentEntry || !(currentEntry instanceof Map)) {\n                    let cardDir = join(directory, name);\n                    let upstreamId = this.ids.get(cardDir);\n                    if (!upstreamId) {\n                        throw new Error(`bug in files-realm tracker. Missing upstream id.`);\n                    }\n                    await ops.delete(upstreamId);\n                    this.ids.delete(cardDir);\n                }\n            }\n        }\n        else {\n            await ops.finishReplaceAll();\n        }\n        this.state.set(directory, now);\n    }\n    async reindexCard(cardDir, entry, directory, ops) {\n        try {\n            let json = assembleCard(cardDir, entry);\n            let upstreamId = {\n                csId: json.data.attributes.csId,\n                csOriginalRealm: json.data.attributes.csOriginalRealm,\n            };\n            await ops.save(upstreamId, new UpstreamDocument(json));\n            this.ids.set(cardDir, upstreamId);\n        }\n        catch (err) {\n            log.warn(`Ignoring card in ${directory} because: ${err}`);\n        }\n    }\n    async targetedUpdate(ops, directory, fileChanged) {\n        if (!fileChanged.startsWith(directory)) {\n            throw new Error(`bug in files-realm tracker: got told about a file that's not ours: ${fileChanged} vs ${directory}`);\n        }\n        let cardDirName = fileChanged.slice(directory.length + 1).split('/')[0];\n        let cardDir = join(directory, cardDirName);\n        let stat;\n        try {\n            stat = statSync(cardDir);\n        }\n        catch (err) {\n            if (err.code !== 'ENOENT') {\n                throw err;\n            }\n        }\n        if (stat && stat.isDirectory()) {\n            let entry = crawl(cardDir);\n            await this.reindexCard(cardDir, entry, directory, ops);\n        }\n        else {\n            let upstreamId = this.ids.get(cardDir);\n            if (upstreamId) {\n                await ops.delete(upstreamId);\n            }\n        }\n    }\n    async subscribe(directory, realmCard) {\n        var _a;\n        if (this.subscriptions.has(directory)) {\n            return;\n        }\n        let enabled = (_a = (await realmCard.value('watcherEnabled')), (_a !== null && _a !== void 0 ? _a : true));\n        if (!enabled) {\n            this.subscriptions.set(directory, { realm: realmCard, watcher: undefined });\n            return;\n        }\n        let watcher = sane(directory, { ignored: ['node_modules'] });\n        watcher.on('add', (filepath, root) => this.notifyFileDidChange(root, filepath));\n        watcher.on('change', (filepath, root) => this.notifyFileDidChange(root, filepath));\n        watcher.on('delete', (filepath, root) => this.notifyFileDidChange(root, filepath));\n        this.subscriptions.set(directory, { realm: realmCard, watcher });\n    }\n    notifyFileDidChange(realmDir, relativeFile) {\n        this.notifyFileDidChangeAndWait(realmDir, relativeFile).catch(err => log.error(`Error while notifying file change %s/%s: %s`, realmDir, relativeFile, err));\n    }\n    async notifyFileDidChangeAndWait(realmDir, relativeFile) {\n        let sub = this.subscriptions.get(realmDir);\n        if (!sub) {\n            log.debug(`Notified about a file we're not subscribed to: realm=${realmDir}, file=${relativeFile}`);\n            return;\n        }\n        let params = { fileChanged: join(realmDir, relativeFile) };\n        await this.indexing.updateRealm(sub.realm, params);\n    }\n    async willTeardown() {\n        for (let { watcher } of this.subscriptions.values()) {\n            if (watcher) {\n                watcher.close();\n            }\n        }\n    }\n}\nfunction changed(previous, current) {\n    if (!previous || !(previous instanceof Map)) {\n        return true;\n    }\n    for (let [name, currentEntry] of current) {\n        let previousEntry = previous.get(name);\n        if (!previousEntry) {\n            return true;\n        }\n        if (currentEntry instanceof Map) {\n            // name is now a directory\n            if (!(previousEntry instanceof Map)) {\n                // previously it was a file, so things changed\n                return true;\n            }\n            return changed(previousEntry, currentEntry);\n        }\n        else {\n            // name is now a file\n            if (previousEntry instanceof Map) {\n                // previously it was a directory, so things changed\n                return true;\n            }\n            if (previousEntry.mtime !== currentEntry.mtime || previousEntry.size !== currentEntry.size) {\n                return true;\n            }\n        }\n    }\n    for (let name of previous.keys()) {\n        if (!current.has(name)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction crawl(cardsDirectory) {\n    let output = new Map();\n    for (let name of readdirSync(cardsDirectory)) {\n        if (name.startsWith('.') || name === 'node_modules') {\n            continue;\n        }\n        let fullName = join(cardsDirectory, name);\n        let stat = statSync(fullName);\n        if (stat.isDirectory()) {\n            output.set(name, crawl(fullName));\n        }\n        else {\n            output.set(name, { mtime: stat.mtime.getDate(), size: stat.size });\n        }\n    }\n    return output;\n}\nfunction assembleCard(cardDirectory, files) {\n    let pkg;\n    try {\n        pkg = readJsonSync(join(cardDirectory, 'package.json'));\n    }\n    catch (err) {\n        if (err.code === 'ENOENT') {\n            throw new Error(`Card does not have a valid package.json file`);\n        }\n        throw err;\n    }\n    let json;\n    try {\n        json = readJsonSync(join(cardDirectory, 'card.json'));\n        assertSingleResourceDoc(json);\n    }\n    catch (err) {\n        if (err.code === 'ENOENT') {\n            throw new Error(`Card does not have a valid card.json file`);\n        }\n        if ('isCardstackError' in err) {\n            throw new Error(`card.json is invalid because: ${err}`);\n        }\n        throw err;\n    }\n    // ensure we have an attributes object\n    merge(json, {\n        data: {\n            attributes: {},\n            meta: {\n                cardDir: cardDirectory,\n            },\n        },\n    });\n    // then ensure that csFiles reflects our true on disk files only\n    json.data.attributes.csFiles = loadFiles(cardDirectory, files, ['package.json', 'card.json']);\n    // and our peerDeps match the ones from package.json\n    // @ts-ignore\n    json.data.attributes.csPeerDependencies = pkg.peerDependencies;\n    return json;\n}\nfunction loadFiles(dir, files, exclude = []) {\n    let output = Object.create(null);\n    for (let [name, entry] of files) {\n        if (exclude.includes(name)) {\n            continue;\n        }\n        let fullName = join(dir, name);\n        if (entry instanceof Map) {\n            output[name] = loadFiles(fullName, entry);\n        }\n        else {\n            output[name] = readFileSync(fullName, 'utf8');\n        }\n    }\n    return output;\n}\n//# sourceMappingURL=tracker.js.map",
          "tracker.js.map": "{\"version\":3,\"file\":\"tracker.js\",\"sourceRoot\":\"\",\"sources\":[\"tracker.ts\"],\"names\":[],\"mappings\":\"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\"}",
          "tracker.ts": "import { statSync, readdirSync, readJsonSync, readFileSync, Stats } from 'fs-extra';\nimport { IndexingOperations } from '@cardstack/hub';\nimport { join } from 'path';\nimport merge from 'lodash/merge';\nimport logger from '@cardstack/logger';\nimport { UpstreamDocument, UpstreamIdentity } from '@cardstack/hub';\nimport { assertSingleResourceDoc } from '@cardstack/hub';\nimport { Card } from '@cardstack/hub';\nimport { SingleResourceDoc } from 'jsonapi-typescript';\nimport { inject } from '@cardstack/hub/dependency-injection';\nimport { AddressableCard } from '@cardstack/hub';\nimport * as J from 'json-typescript';\nimport sane from 'sane';\n\nconst log = logger('files-realm-tracker');\n\nexport interface TrackerParams {\n  fileChanged?: string;\n}\n\n// This holds the persistent state for the files-realm while the hub is running.\n// It deals with file watching and noticing incremental changes.\nexport class FilesTracker {\n  indexing = inject('indexing');\n\n  private state: Map<string, Map<string, Entry>> = new Map();\n  private ids: Map<string, UpstreamIdentity> = new Map();\n  private subscriptions: Map<string, { realm: AddressableCard; watcher: undefined | sane.Watcher }> = new Map();\n\n  async update(realmCard: AddressableCard, ops: IndexingOperations, params: TrackerParams | null): Promise<void> {\n    let directory = await realmCard.value('directory');\n\n    if (params?.fileChanged) {\n      await this.targetedUpdate(ops, directory, params.fileChanged);\n      return;\n    }\n\n    await this.subscribe(directory, realmCard);\n    let now = crawl(directory);\n    let previous = this.state.get(directory);\n\n    if (!previous) {\n      await ops.beginReplaceAll();\n    }\n\n    for (let [name, entry] of now) {\n      if (entry instanceof Map) {\n        // we found a directory within the top-level cards directory, so it's\n        // supposed to be card.\n\n        if (previous && !changed(previous.get(name), entry)) {\n          continue;\n        }\n        let cardDir = join(directory, name);\n        await this.reindexCard(cardDir, entry, directory, ops);\n      } else {\n        // we found a file in within the top-level cards directory, we ignore\n        // those.\n      }\n    }\n\n    if (previous) {\n      for (let [name, previousEntry] of previous) {\n        if (!(previousEntry instanceof Map)) {\n          // it was a file before, so there's no chance we need to delete a card\n          continue;\n        }\n\n        // it was a directory before, so we're responsible for checking that\n        // it's still a card.\n\n        let currentEntry = now.get(name);\n\n        // if the directory has been deleted or replaced with a file, we need to\n        // remove from search index\n        if (!currentEntry || !(currentEntry instanceof Map)) {\n          let cardDir = join(directory, name);\n          let upstreamId = this.ids.get(cardDir);\n          if (!upstreamId) {\n            throw new Error(`bug in files-realm tracker. Missing upstream id.`);\n          }\n          await ops.delete(upstreamId);\n          this.ids.delete(cardDir);\n        }\n      }\n    } else {\n      await ops.finishReplaceAll();\n    }\n    this.state.set(directory, now);\n  }\n\n  private async reindexCard(cardDir: string, entry: Map<string, Entry>, directory: string, ops: IndexingOperations) {\n    try {\n      let json = assembleCard(cardDir, entry);\n      let upstreamId = {\n        csId: json.data.attributes!.csId as string,\n        csOriginalRealm: json.data.attributes!.csOriginalRealm as string,\n      };\n      await ops.save(upstreamId, new UpstreamDocument(json));\n      this.ids.set(cardDir, upstreamId);\n    } catch (err) {\n      log.warn(`Ignoring card in ${directory} because: ${err}`);\n    }\n  }\n\n  private async targetedUpdate(ops: IndexingOperations, directory: string, fileChanged: string): Promise<void> {\n    if (!fileChanged.startsWith(directory)) {\n      throw new Error(\n        `bug in files-realm tracker: got told about a file that's not ours: ${fileChanged} vs ${directory}`\n      );\n    }\n    let cardDirName = fileChanged.slice(directory.length + 1).split('/')[0];\n    let cardDir = join(directory, cardDirName);\n    let stat: Stats | undefined;\n    try {\n      stat = statSync(cardDir);\n    } catch (err) {\n      if (err.code !== 'ENOENT') {\n        throw err;\n      }\n    }\n    if (stat && stat.isDirectory()) {\n      let entry = crawl(cardDir);\n      await this.reindexCard(cardDir, entry, directory, ops);\n    } else {\n      let upstreamId = this.ids.get(cardDir);\n      if (upstreamId) {\n        await ops.delete(upstreamId);\n      }\n    }\n  }\n\n  private async subscribe(directory: string, realmCard: AddressableCard): Promise<void> {\n    if (this.subscriptions.has(directory)) {\n      return;\n    }\n    let enabled: boolean = (await realmCard.value('watcherEnabled')) ?? true;\n    if (!enabled) {\n      this.subscriptions.set(directory, { realm: realmCard, watcher: undefined });\n      return;\n    }\n\n    let watcher = sane(directory, { ignored: ['node_modules'] });\n    watcher.on('add', (filepath, root) => this.notifyFileDidChange(root, filepath));\n    watcher.on('change', (filepath, root) => this.notifyFileDidChange(root, filepath));\n    watcher.on('delete', (filepath, root) => this.notifyFileDidChange(root, filepath));\n    this.subscriptions.set(directory, { realm: realmCard, watcher });\n  }\n\n  notifyFileDidChange(realmDir: string, relativeFile: string): void {\n    this.notifyFileDidChangeAndWait(realmDir, relativeFile).catch(err =>\n      log.error(`Error while notifying file change %s/%s: %s`, realmDir, relativeFile, err)\n    );\n  }\n\n  async notifyFileDidChangeAndWait(realmDir: string, relativeFile: string): Promise<void> {\n    let sub = this.subscriptions.get(realmDir);\n    if (!sub) {\n      log.debug(`Notified about a file we're not subscribed to: realm=${realmDir}, file=${relativeFile}`);\n      return;\n    }\n    let params: TrackerParams = { fileChanged: join(realmDir, relativeFile) };\n    await this.indexing.updateRealm(sub.realm, params as J.Object);\n  }\n\n  async willTeardown() {\n    for (let { watcher } of this.subscriptions.values()) {\n      if (watcher) {\n        watcher.close();\n      }\n    }\n  }\n}\n\nfunction changed(previous: Entry | undefined, current: Map<string, Entry>): boolean {\n  if (!previous || !(previous instanceof Map)) {\n    return true;\n  }\n  for (let [name, currentEntry] of current) {\n    let previousEntry = previous.get(name);\n    if (!previousEntry) {\n      return true;\n    }\n\n    if (currentEntry instanceof Map) {\n      // name is now a directory\n      if (!(previousEntry instanceof Map)) {\n        // previously it was a file, so things changed\n        return true;\n      }\n      return changed(previousEntry, currentEntry);\n    } else {\n      // name is now a file\n      if (previousEntry instanceof Map) {\n        // previously it was a directory, so things changed\n        return true;\n      }\n      if (previousEntry.mtime !== currentEntry.mtime || previousEntry.size !== currentEntry.size) {\n        return true;\n      }\n    }\n  }\n  for (let name of previous.keys()) {\n    if (!current.has(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\ntype Entry = { mtime: number; size: number } | Map<string, Entry>;\n\nfunction crawl(cardsDirectory: string): Map<string, Entry> {\n  let output: Map<string, Entry> = new Map();\n  for (let name of readdirSync(cardsDirectory)) {\n    if (name.startsWith('.') || name === 'node_modules') {\n      continue;\n    }\n    let fullName = join(cardsDirectory, name);\n    let stat = statSync(fullName);\n    if (stat.isDirectory()) {\n      output.set(name, crawl(fullName));\n    } else {\n      output.set(name, { mtime: stat.mtime.getDate(), size: stat.size });\n    }\n  }\n  return output;\n}\n\nfunction assembleCard(cardDirectory: string, files: Map<string, Entry>): SingleResourceDoc {\n  let pkg;\n  try {\n    pkg = readJsonSync(join(cardDirectory, 'package.json'));\n  } catch (err) {\n    if (err.code === 'ENOENT') {\n      throw new Error(`Card does not have a valid package.json file`);\n    }\n    throw err;\n  }\n\n  let json;\n  try {\n    json = readJsonSync(join(cardDirectory, 'card.json'));\n    assertSingleResourceDoc(json);\n  } catch (err) {\n    if (err.code === 'ENOENT') {\n      throw new Error(`Card does not have a valid card.json file`);\n    }\n    if ('isCardstackError' in err) {\n      throw new Error(`card.json is invalid because: ${err}`);\n    }\n    throw err;\n  }\n\n  // ensure we have an attributes object\n  merge(json, {\n    data: {\n      attributes: {},\n      meta: {\n        cardDir: cardDirectory,\n      },\n    },\n  });\n\n  // then ensure that csFiles reflects our true on disk files only\n  json.data.attributes!.csFiles = loadFiles(cardDirectory, files, ['package.json', 'card.json']);\n\n  // and our peerDeps match the ones from package.json\n  // @ts-ignore\n  json.data.attributes!.csPeerDependencies = pkg.peerDependencies;\n  return json;\n}\n\nfunction loadFiles(dir: string, files: Map<string, Entry>, exclude: string[] = []) {\n  let output: NonNullable<Card['csFiles']> = Object.create(null);\n  for (let [name, entry] of files) {\n    if (exclude.includes(name)) {\n      continue;\n    }\n    let fullName = join(dir, name);\n    if (entry instanceof Map) {\n      output[name] = loadFiles(fullName, entry);\n    } else {\n      output[name] = readFileSync(fullName, 'utf8');\n    }\n  }\n  return output;\n}\n\ndeclare module '@cardstack/hub/dependency-injection' {\n  interface KnownServices {\n    filesTracker: FilesTracker;\n  }\n}\n",
          "writer.d.ts": "import { Writer } from '@cardstack/hub';\nimport { Session } from '@cardstack/hub';\nimport { UpstreamDocument, UpstreamIdentity } from '@cardstack/hub';\nimport { AddressableCard } from '@cardstack/hub';\nexport default class FilesWriter implements Writer {\n    private realmCard;\n    filesTracker: import(\"./tracker\").FilesTracker;\n    constructor(realmCard: AddressableCard);\n    create(_session: Session, doc: UpstreamDocument, upstreamId: UpstreamIdentity | null): Promise<{\n        saved: UpstreamDocument;\n        id: UpstreamIdentity;\n    }>;\n    update(_session: Session, id: UpstreamIdentity, doc: UpstreamDocument): Promise<UpstreamDocument>;\n    delete(_session: Session, id: UpstreamIdentity): Promise<void>;\n    private createOrUpdateCard;\n    private pickId;\n}\n",
          "writer.js": "import { inject } from '@cardstack/hub/dependency-injection';\nimport crypto from 'crypto';\nimport { pathExistsSync, removeSync, outputFileSync } from 'fs-extra';\nimport { join } from 'path';\nimport { writeCard } from '@cardstack/hub';\nimport { upstreamIdToCardDirName } from '@cardstack/hub';\nexport default class FilesWriter {\n    constructor(realmCard) {\n        this.realmCard = realmCard;\n        this.filesTracker = inject('filesTracker');\n    }\n    async create(_session, doc, upstreamId) {\n        let realmDir = await this.realmCard.value('directory');\n        let cardDirName;\n        if (!upstreamId) {\n            cardDirName = this.pickId(realmDir);\n        }\n        else {\n            cardDirName = upstreamIdToCardDirName(upstreamId);\n        }\n        let cardDir = join(realmDir, cardDirName);\n        let saved = await this.createOrUpdateCard(cardDir, doc);\n        return { saved, id: (upstreamId !== null && upstreamId !== void 0 ? upstreamId : cardDirName) };\n    }\n    async update(_session, id, doc) {\n        let realmDir = await this.realmCard.value('directory');\n        let cardDirName = upstreamIdToCardDirName(id);\n        let cardDir = join(realmDir, cardDirName);\n        removeSync(cardDir);\n        let saved = await this.createOrUpdateCard(cardDir, doc);\n        return saved;\n    }\n    async delete(_session, id) {\n        let realmDir = await this.realmCard.value('directory');\n        let cardDirName = upstreamIdToCardDirName(id);\n        let cardDir = join(realmDir, cardDirName);\n        removeSync(cardDir);\n    }\n    async createOrUpdateCard(cardDir, doc) {\n        await writeCard(cardDir, doc.jsonapi, async (path, content) => {\n            outputFileSync(path, content, 'utf8');\n        });\n        let meta = Object.assign({}, doc.jsonapi.data.meta);\n        meta.cardDir = cardDir;\n        doc.jsonapi.data.meta = meta;\n        return doc;\n    }\n    pickId(realmDir) {\n        while (true) {\n            let id = crypto.randomBytes(20).toString('hex');\n            if (!pathExistsSync(join(realmDir, id))) {\n                return id;\n            }\n        }\n    }\n}\n//# sourceMappingURL=writer.js.map",
          "writer.js.map": "{\"version\":3,\"file\":\"writer.js\",\"sourceRoot\":\"\",\"sources\":[\"writer.ts\"],\"names\":[],\"mappings\":\"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\"}",
          "writer.ts": "import { Writer } from '@cardstack/hub';\nimport { Session } from '@cardstack/hub';\nimport { UpstreamDocument, UpstreamIdentity } from '@cardstack/hub';\nimport { inject } from '@cardstack/hub/dependency-injection';\nimport { AddressableCard } from '@cardstack/hub';\nimport crypto from 'crypto';\nimport { pathExistsSync, removeSync, outputFileSync } from 'fs-extra';\nimport { join } from 'path';\nimport { writeCard } from '@cardstack/hub';\nimport { upstreamIdToCardDirName } from '@cardstack/hub';\n\nexport default class FilesWriter implements Writer {\n  filesTracker = inject('filesTracker');\n\n  constructor(private realmCard: AddressableCard) {}\n\n  async create(_session: Session, doc: UpstreamDocument, upstreamId: UpstreamIdentity | null) {\n    let realmDir = await this.realmCard.value('directory');\n    let cardDirName: string;\n    if (!upstreamId) {\n      cardDirName = this.pickId(realmDir);\n    } else {\n      cardDirName = upstreamIdToCardDirName(upstreamId);\n    }\n\n    let cardDir = join(realmDir, cardDirName);\n    let saved = await this.createOrUpdateCard(cardDir, doc);\n    return { saved, id: upstreamId ?? cardDirName };\n  }\n\n  async update(_session: Session, id: UpstreamIdentity, doc: UpstreamDocument) {\n    let realmDir = await this.realmCard.value('directory');\n    let cardDirName = upstreamIdToCardDirName(id);\n    let cardDir = join(realmDir, cardDirName);\n    removeSync(cardDir);\n    let saved = await this.createOrUpdateCard(cardDir, doc);\n    return saved;\n  }\n\n  async delete(_session: Session, id: UpstreamIdentity) {\n    let realmDir = await this.realmCard.value('directory');\n    let cardDirName = upstreamIdToCardDirName(id);\n    let cardDir = join(realmDir, cardDirName);\n    removeSync(cardDir);\n  }\n\n  private async createOrUpdateCard(cardDir: string, doc: UpstreamDocument): Promise<UpstreamDocument> {\n    await writeCard(cardDir, doc.jsonapi, async (path: string, content: string) => {\n      outputFileSync(path, content, 'utf8');\n    });\n    let meta = Object.assign({}, doc.jsonapi.data.meta);\n    meta.cardDir = cardDir;\n    doc.jsonapi.data.meta = meta;\n    return doc;\n  }\n\n  private pickId(realmDir: string): string {\n    while (true) {\n      let id = crypto.randomBytes(20).toString('hex');\n      if (!pathExistsSync(join(realmDir, id))) {\n        return id;\n      }\n    }\n  }\n}\n"
        },
        "csId": "files-realm",
        "csPeerDependencies": {
          "@cardstack/hub": "*"
        },
        "csUpdated": "2020-11-17T21:16:30.160Z"
      },
      "id": "https://base.cardstack.com/public/cards/files-realm",
      "meta": {
        "cardDir": "/cardstack/node_modules/@cardstack/files-realm-card"
      },
      "relationships": {
        "csAdoptsFrom": {
          "data": {
            "id": "https://base.cardstack.com/public/cards/base",
            "type": "cards"
          }
        }
      },
      "type": "cards"
    },
    {
      "attributes": {
        "csCreated": "2020-11-17T21:16:30.164Z",
        "csDescription": "This represents cards of any type",
        "csFeatures": {
          "embedded-css": "embedded.css",
          "isolated-css": "isolated.css"
        },
        "csFiles": {
          "card.json": "{\n  \"data\": {\n    \"type\": \"cards\",\n    \"attributes\": {\n      \"csId\": \"base\",\n      \"csTitle\": \"Base Card\",\n      \"csDescription\": \"This represents cards of any type\",\n      \"csFeatures\": {\n        \"isolated-css\": \"isolated.css\",\n        \"embedded-css\": \"embedded.css\"\n      }\n    },\n    \"relationships\": {\n    }\n  }\n}",
          "embedded.css": "/* This is the embedded base card template. All cards will inherit this CSS if\nno custom CSS is provided for the card.*/\n\n.card-boundary {\n  width: 100%;\n  max-width: 450px;\n  min-height: 90px;\n  margin: 0;\n  border-radius: 10px;\n  background-color: white;\n  color: black;\n  font: 400 10px/1.2 'Open Sans';\n  letter-spacing: 0.03em;\n  text-align: left;\n  overflow: hidden;\n  overflow-wrap: break-word;\n  word-break: break-word;\n}\n\n.embedded-card--view-fields {\n  display: grid; /* Helpful for ordering fields */\n}\n.embedded-card--view-fields::before,\n.embedded-card--view-fields::after {\n  height: 0; /* for firefox */\n}\n\n.field {\n  display: grid;\n  grid-template-columns: 1fr 1.5fr;\n  grid-gap: 0 10px;\n  width: 100%;\n  margin: 0 auto;\n  padding: 0 15px 15px;\n}\n.field.field-type-belongs-to-view-field,\n.field:first-of-type {\n  padding-top: 15px;\n}\n\n.label {\n  padding-bottom: 4px;\n  color: var(--black);\n  font-size: 7px;\n  font-weight: bold;\n  letter-spacing: 0.1em;\n  line-height: 1.364;\n  text-transform: uppercase;\n}\n\n\n/**** SPECIAL FIELD TYPES ****/\n\n/* field-type: link */\n/* use `label` for link text and `value` for link url */\n.link-viewer {\n  color: var(--cobalt-blue);\n  text-decoration: underline;\n  font-weight: 600;\n}\n\n/* field-type: cta */\n/* use `label` for button text and `value` for button link url */\n.cta-viewer {\n  min-height: 1em;\n  border-radius: 6px;\n  font-size: 10px;\n  font-weight: 700;\n  line-height: calc(22 / 15);\n  letter-spacing: 0.03em;\n  padding: 6px;\n}\n\n/* field-type: decorative-image */\n.decorative-image-viewer {\n  max-height: 50px;\n}\n\n\n/**** SPECIAL FIELD IDs ****/\n\n/* field-id: background-image */\n.background-image-field {\n  display: block;\n  max-width: 100%;\n  padding: 0;\n  order: -100; /* first item on page */\n}\n.background-image-field > .label {\n  display: none;\n}\n.background-image-field > .value {\n  width: 100%;\n  max-height: 75px;\n  object-fit: cover;\n  object-position: center;\n}\n\n/* field-id: title */\n.title-field {\n  display: block;\n  padding-bottom: 7px;\n}\n.title-field > .label {\n  display: none;\n}\n.title-field > .value {\n  color: var(--dark-gray);\n  font-size: 14px;\n  font-weight: bold;\n  letter-spacing: 0.015em;\n  line-height: 1.2;\n}\n\n/* field-id: highlight-title */\n.highlight-title-field {\n  display: block;\n}\n.highlight-title-field > .label {\n  display: none;\n}\n.highlight-title-field > .value {\n  color: var(--red);\n  font-size: 10px;\n  font-weight: bold;\n  letter-spacing: 0.035em;\n  text-transform: capitalize;\n}\n\n/* field-id: divider */\n.divider-field {\n  display: block;\n  width: calc(100% - 30px);\n  border-top: 1px solid var(--light-gray);\n}\n.divider-field > .label,\n.divider-field > .value {\n  display: none;\n}\n\n/* field-id: description */\n.description-field {\n  display: block;\n}\n",
          "isolated.css": "/* This is the isolated base card template. All cards will inherit this CSS if\nno custom CSS is provided for the card.*/\n\n.isolated-card {\n  margin: 0 auto;\n  background-color: #fff;\n  color: #000;\n  font-family: 'Open Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif;\n  font-size: 16px;\n  line-height: calc(22/16);\n  letter-spacing: 0.015em;\n}\n\n.isolated-card--view-fields {\n  display: grid;\n  gap: 10px;\n  padding: 30px;\n}\n\n.field {\n  display: grid;\n  grid-template-columns: 2fr 4.5fr;\n  gap: 30px;\n  max-width: 700px;\n  width: 100%;\n  margin: 0 auto;\n  padding: 10px;\n}\n\n.label {\n  font-size: 13px;\n  font-weight: 700;\n  letter-spacing: 0.05em;\n  line-height: calc(22/13);\n  text-transform: uppercase;\n  text-align: right;\n  text-overflow: ellipsis;\n  overflow: hidden;\n}\n\n.value {\n  max-width: 100%;\n  text-overflow: ellipsis;\n  overflow: hidden;\n}\n",
          "package.json": "{\n  \"name\": \"@cardstack/base-card\",\n  \"version\": \"0.18.17\",\n  \"license\": \"MIT\",\n  \"publishConfig\": {\n    \"access\": \"public\"\n  },\n  \"peerDependencies\": {\n    \"@cardstack/hub\": \"*\"\n  },\n  \"devDependencies\": {\n    \"@cardstack/hub\": \"0.18.17\"\n  },\n  \"volta\": {\n    \"node\": \"12.13.1\",\n    \"yarn\": \"1.22.0\"\n  }\n}\n"
        },
        "csId": "base",
        "csPeerDependencies": {
          "@cardstack/hub": "*"
        },
        "csTitle": "Base Card",
        "csUpdated": "2020-11-17T21:16:30.164Z"
      },
      "id": "https://base.cardstack.com/public/cards/base",
      "meta": {
        "cardDir": "/cardstack/node_modules/@cardstack/base-card"
      },
      "relationships": {
      },
      "type": "cards"
    }
  ]
}